{
  "$schema": "https://raw.githubusercontent.com/sseuniverse/sse-hooks/refs/heads/main/schema/meta.json",
  "name": "use-click-away",
  "type": "registry:hook",
  "title": "useClickAway",
  "description": "Supported touch events for the click-away listener.",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [
    "use-fork-ref",
    "use-event-callback"
  ],
  "file": {
    "content": "import React from \"react\";\r\n\nexport default function ownerDocument(node: Node | null | undefined): Document {\r\n  return (node && node.ownerDocument) || document;\r\n}\r\n\n\n\r\ntype ClickAwayTouchEventHandler = \"onTouchStart\" | \"onTouchEnd\";\r\n\r\n\r\ntype ClickAwayMouseEventHandler =\r\n  | \"onClick\"\r\n  | \"onMouseDown\"\r\n  | \"onMouseUp\"\r\n  | \"onPointerDown\"\r\n  | \"onPointerUp\";\r\n\r\n\r\nexport interface UseClickAwayOptions {\r\n  \r\n  disableReactTree?: boolean;\r\n  \r\n  mouseEvent?: ClickAwayMouseEventHandler | false;\r\n  \r\n  touchEvent?: ClickAwayTouchEventHandler | false;\r\n  \r\n  ref?: React.Ref<Element>;\r\n}\r\n\r\nfunction mapEventPropToEvent(\r\n  eventProp: ClickAwayMouseEventHandler | ClickAwayTouchEventHandler,\r\n):\r\n  | \"click\"\r\n  | \"mousedown\"\r\n  | \"mouseup\"\r\n  | \"touchstart\"\r\n  | \"touchend\"\r\n  | \"pointerdown\"\r\n  | \"pointerup\" {\r\n  return eventProp.substring(2).toLowerCase() as any;\r\n}\r\n\r\nfunction clickedRootScrollbar(event: MouseEvent, doc: Document) {\r\n  return (\r\n    doc.documentElement.clientWidth < event.clientX ||\r\n    doc.documentElement.clientHeight < event.clientY\r\n  );\r\n}\r\n\r\n\r\nexport function useClickAway(\r\n  onClickAway: (event: MouseEvent | TouchEvent) => void,\r\n  options: UseClickAwayOptions = {},\r\n): { ref: React.Ref<Element>; listenerProps: Record<string, any> } {\r\n  const {\r\n    disableReactTree = false,\r\n    mouseEvent = \"onClick\",\r\n    touchEvent = \"onTouchEnd\",\r\n    ref: externalRef,\r\n  } = options;\r\n\r\n  \r\n  const internalRef = React.useRef<Element>(null);\r\n\r\n  \r\n  const handleRef = useForkRef(externalRef, internalRef);\r\n\r\n  const movedRef = React.useRef(false);\r\n  const activatedRef = React.useRef(false);\r\n  const syntheticEventRef = React.useRef(false);\r\n\r\n  React.useEffect(() => {\r\n    \r\n    \r\n    const timer = setTimeout(() => {\r\n      activatedRef.current = true;\r\n    }, 0);\r\n\r\n    return () => {\r\n      activatedRef.current = false;\r\n      clearTimeout(timer);\r\n    };\r\n  }, []);\r\n\r\n  const handleClickAway = useEventCallback((event: MouseEvent | TouchEvent) => {\r\n    \r\n    \r\n    const insideReactTree = syntheticEventRef.current;\r\n    syntheticEventRef.current = false;\r\n\r\n    const doc = ownerDocument(internalRef.current);\r\n\r\n    \r\n    \r\n    \r\n    if (\r\n      !activatedRef.current ||\r\n      !internalRef.current ||\r\n      (\"clientX\" in event && clickedRootScrollbar(event as MouseEvent, doc))\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    \r\n    if (movedRef.current) {\r\n      movedRef.current = false;\r\n      return;\r\n    }\r\n\r\n    let insideDOM;\r\n\r\n    \r\n    if (event.composedPath) {\r\n      insideDOM = event.composedPath().includes(internalRef.current);\r\n    } else {\r\n      insideDOM =\r\n        !doc.documentElement.contains(\r\n          \r\n          event.target,\r\n        ) ||\r\n        internalRef.current.contains(\r\n          \r\n          event.target,\r\n        );\r\n    }\r\n\r\n    if (!insideDOM && (disableReactTree || !insideReactTree)) {\r\n      onClickAway(event);\r\n    }\r\n  });\r\n\r\n  \r\n  const createHandleSynthetic = (event: React.SyntheticEvent) => {\r\n    syntheticEventRef.current = true;\r\n  };\r\n\r\n  React.useEffect(() => {\r\n    if (touchEvent !== false) {\r\n      const mappedTouchEvent = mapEventPropToEvent(touchEvent);\r\n      const doc = ownerDocument(internalRef.current);\r\n\r\n      const handleTouchMove = () => {\r\n        movedRef.current = true;\r\n      };\r\n\r\n      doc.addEventListener(mappedTouchEvent, handleClickAway);\r\n      doc.addEventListener(\"touchmove\", handleTouchMove);\r\n\r\n      return () => {\r\n        doc.removeEventListener(mappedTouchEvent, handleClickAway);\r\n        doc.removeEventListener(\"touchmove\", handleTouchMove);\r\n      };\r\n    }\r\n\r\n    return undefined;\r\n  }, [handleClickAway, touchEvent]);\r\n\r\n  React.useEffect(() => {\r\n    if (mouseEvent !== false) {\r\n      const mappedMouseEvent = mapEventPropToEvent(mouseEvent);\r\n      const doc = ownerDocument(internalRef.current);\r\n\r\n      doc.addEventListener(mappedMouseEvent, handleClickAway);\r\n\r\n      return () => {\r\n        doc.removeEventListener(mappedMouseEvent, handleClickAway);\r\n      };\r\n    }\r\n\r\n    return undefined;\r\n  }, [handleClickAway, mouseEvent]);\r\n\r\n  \r\n  const listenerProps: Record<string, any> = {};\r\n  if (mouseEvent !== false) {\r\n    listenerProps[mouseEvent] = createHandleSynthetic;\r\n  }\r\n  if (touchEvent !== false) {\r\n    listenerProps[touchEvent] = createHandleSynthetic;\r\n  }\r\n\r\n  return {\r\n    ref: handleRef,\r\n    listenerProps,\r\n  };\r\n}",
    "js": "import React from \"react\";\nexport default function ownerDocument(node) {\n    return (node && node.ownerDocument) || document;\n}\nfunction mapEventPropToEvent(eventProp) {\n    return eventProp.substring(2).toLowerCase();\n}\nfunction clickedRootScrollbar(event, doc) {\n    return (doc.documentElement.clientWidth < event.clientX ||\n        doc.documentElement.clientHeight < event.clientY);\n}\nexport function useClickAway(onClickAway, options = {}) {\n    const { disableReactTree = false, mouseEvent = \"onClick\", touchEvent = \"onTouchEnd\", ref: externalRef, } = options;\n    const internalRef = React.useRef(null);\n    const handleRef = useForkRef(externalRef, internalRef);\n    const movedRef = React.useRef(false);\n    const activatedRef = React.useRef(false);\n    const syntheticEventRef = React.useRef(false);\n    React.useEffect(() => {\n        const timer = setTimeout(() => {\n            activatedRef.current = true;\n        }, 0);\n        return () => {\n            activatedRef.current = false;\n            clearTimeout(timer);\n        };\n    }, []);\n    const handleClickAway = useEventCallback((event) => {\n        const insideReactTree = syntheticEventRef.current;\n        syntheticEventRef.current = false;\n        const doc = ownerDocument(internalRef.current);\n        if (!activatedRef.current ||\n            !internalRef.current ||\n            (\"clientX\" in event && clickedRootScrollbar(event, doc))) {\n            return;\n        }\n        if (movedRef.current) {\n            movedRef.current = false;\n            return;\n        }\n        let insideDOM;\n        if (event.composedPath) {\n            insideDOM = event.composedPath().includes(internalRef.current);\n        }\n        else {\n            insideDOM =\n                !doc.documentElement.contains(event.target) ||\n                    internalRef.current.contains(event.target);\n        }\n        if (!insideDOM && (disableReactTree || !insideReactTree)) {\n            onClickAway(event);\n        }\n    });\n    const createHandleSynthetic = (event) => {\n        syntheticEventRef.current = true;\n    };\n    React.useEffect(() => {\n        if (touchEvent !== false) {\n            const mappedTouchEvent = mapEventPropToEvent(touchEvent);\n            const doc = ownerDocument(internalRef.current);\n            const handleTouchMove = () => {\n                movedRef.current = true;\n            };\n            doc.addEventListener(mappedTouchEvent, handleClickAway);\n            doc.addEventListener(\"touchmove\", handleTouchMove);\n            return () => {\n                doc.removeEventListener(mappedTouchEvent, handleClickAway);\n                doc.removeEventListener(\"touchmove\", handleTouchMove);\n            };\n        }\n        return undefined;\n    }, [handleClickAway, touchEvent]);\n    React.useEffect(() => {\n        if (mouseEvent !== false) {\n            const mappedMouseEvent = mapEventPropToEvent(mouseEvent);\n            const doc = ownerDocument(internalRef.current);\n            doc.addEventListener(mappedMouseEvent, handleClickAway);\n            return () => {\n                doc.removeEventListener(mappedMouseEvent, handleClickAway);\n            };\n        }\n        return undefined;\n    }, [handleClickAway, mouseEvent]);\n    const listenerProps = {};\n    if (mouseEvent !== false) {\n        listenerProps[mouseEvent] = createHandleSynthetic;\n    }\n    if (touchEvent !== false) {\n        listenerProps[touchEvent] = createHandleSynthetic;\n    }\n    return {\n        ref: handleRef,\n        listenerProps,\n    };\n}"
  }
}