{
  "$schema": "https://sse-hooks.vercel.app/api/registry/schema/hook.json",
  "name": "use-click-away",
  "type": "registry:hook",
  "title": "useClickAway",
  "description": "Supported touch events for the click-away listener.",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [
    "use-fork-ref",
    "use-event-callback"
  ],
  "file": {
    "content": "import React from \"react\";\nimport { useForkRef } from \"./use-fork-ref\";\nexport default function ownerDocument(node: Node | null | undefined): Document {\n  return (node && node.ownerDocument) || document;\n}\n\nimport { useEventCallback } from \"./use-event-callback\";\n\ntype ClickAwayTouchEventHandler = \"onTouchStart\" | \"onTouchEnd\";\n\ntype ClickAwayMouseEventHandler =\n  | \"onClick\"\n  | \"onMouseDown\"\n  | \"onMouseUp\"\n  | \"onPointerDown\"\n  | \"onPointerUp\";\n\nexport interface UseClickAwayOptions {\n  disableReactTree?: boolean;\n\n  mouseEvent?: ClickAwayMouseEventHandler | false;\n\n  touchEvent?: ClickAwayTouchEventHandler | false;\n\n  ref?: React.Ref<Element>;\n}\n\nfunction mapEventPropToEvent(\n  eventProp: ClickAwayMouseEventHandler | ClickAwayTouchEventHandler,\n):\n  | \"click\"\n  | \"mousedown\"\n  | \"mouseup\"\n  | \"touchstart\"\n  | \"touchend\"\n  | \"pointerdown\"\n  | \"pointerup\" {\n  return eventProp.substring(2).toLowerCase() as any;\n}\n\nfunction clickedRootScrollbar(event: MouseEvent, doc: Document) {\n  return (\n    doc.documentElement.clientWidth < event.clientX ||\n    doc.documentElement.clientHeight < event.clientY\n  );\n}\n\nexport function useClickAway(\n  onClickAway: (event: MouseEvent | TouchEvent) => void,\n  options: UseClickAwayOptions = {},\n): { ref: React.Ref<Element>; listenerProps: Record<string, any> } {\n  const {\n    disableReactTree = false,\n    mouseEvent = \"onClick\",\n    touchEvent = \"onTouchEnd\",\n    ref: externalRef,\n  } = options;\n\n  const internalRef = React.useRef<Element>(null);\n\n  const handleRef = useForkRef(externalRef, internalRef);\n\n  const movedRef = React.useRef(false);\n  const activatedRef = React.useRef(false);\n  const syntheticEventRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const timer = setTimeout(() => {\n      activatedRef.current = true;\n    }, 0);\n\n    return () => {\n      activatedRef.current = false;\n      clearTimeout(timer);\n    };\n  }, []);\n\n  const handleClickAway = useEventCallback((event: MouseEvent | TouchEvent) => {\n    const insideReactTree = syntheticEventRef.current;\n    syntheticEventRef.current = false;\n\n    const doc = ownerDocument(internalRef.current);\n\n    if (\n      !activatedRef.current ||\n      !internalRef.current ||\n      (\"clientX\" in event && clickedRootScrollbar(event as MouseEvent, doc))\n    ) {\n      return;\n    }\n\n    if (movedRef.current) {\n      movedRef.current = false;\n      return;\n    }\n\n    let insideDOM;\n\n    if (event.composedPath) {\n      insideDOM = event.composedPath().includes(internalRef.current);\n    } else {\n      insideDOM =\n        !doc.documentElement.contains(event.target) ||\n        internalRef.current.contains(event.target);\n    }\n\n    if (!insideDOM && (disableReactTree || !insideReactTree)) {\n      onClickAway(event);\n    }\n  });\n\n  const createHandleSynthetic = (event: React.SyntheticEvent) => {\n    syntheticEventRef.current = true;\n  };\n\n  React.useEffect(() => {\n    if (touchEvent !== false) {\n      const mappedTouchEvent = mapEventPropToEvent(touchEvent);\n      const doc = ownerDocument(internalRef.current);\n\n      const handleTouchMove = () => {\n        movedRef.current = true;\n      };\n\n      doc.addEventListener(mappedTouchEvent, handleClickAway);\n      doc.addEventListener(\"touchmove\", handleTouchMove);\n\n      return () => {\n        doc.removeEventListener(mappedTouchEvent, handleClickAway);\n        doc.removeEventListener(\"touchmove\", handleTouchMove);\n      };\n    }\n\n    return undefined;\n  }, [handleClickAway, touchEvent]);\n\n  React.useEffect(() => {\n    if (mouseEvent !== false) {\n      const mappedMouseEvent = mapEventPropToEvent(mouseEvent);\n      const doc = ownerDocument(internalRef.current);\n\n      doc.addEventListener(mappedMouseEvent, handleClickAway);\n\n      return () => {\n        doc.removeEventListener(mappedMouseEvent, handleClickAway);\n      };\n    }\n\n    return undefined;\n  }, [handleClickAway, mouseEvent]);\n\n  const listenerProps: Record<string, any> = {};\n  if (mouseEvent !== false) {\n    listenerProps[mouseEvent] = createHandleSynthetic;\n  }\n  if (touchEvent !== false) {\n    listenerProps[touchEvent] = createHandleSynthetic;\n  }\n\n  return {\n    ref: handleRef,\n    listenerProps,\n  };\n}\n",
    "js": "import React from \"react\";\nimport { useForkRef } from \"./use-fork-ref\";\nexport default function ownerDocument(node) {\n    return (node && node.ownerDocument) || document;\n}\nimport { useEventCallback } from \"./use-event-callback\";\nfunction mapEventPropToEvent(eventProp) {\n    return eventProp.substring(2).toLowerCase();\n}\nfunction clickedRootScrollbar(event, doc) {\n    return (doc.documentElement.clientWidth < event.clientX ||\n        doc.documentElement.clientHeight < event.clientY);\n}\nexport function useClickAway(onClickAway, options = {}) {\n    const { disableReactTree = false, mouseEvent = \"onClick\", touchEvent = \"onTouchEnd\", ref: externalRef, } = options;\n    const internalRef = React.useRef(null);\n    const handleRef = useForkRef(externalRef, internalRef);\n    const movedRef = React.useRef(false);\n    const activatedRef = React.useRef(false);\n    const syntheticEventRef = React.useRef(false);\n    React.useEffect(() => {\n        const timer = setTimeout(() => {\n            activatedRef.current = true;\n        }, 0);\n        return () => {\n            activatedRef.current = false;\n            clearTimeout(timer);\n        };\n    }, []);\n    const handleClickAway = useEventCallback((event) => {\n        const insideReactTree = syntheticEventRef.current;\n        syntheticEventRef.current = false;\n        const doc = ownerDocument(internalRef.current);\n        if (!activatedRef.current ||\n            !internalRef.current ||\n            (\"clientX\" in event && clickedRootScrollbar(event, doc))) {\n            return;\n        }\n        if (movedRef.current) {\n            movedRef.current = false;\n            return;\n        }\n        let insideDOM;\n        if (event.composedPath) {\n            insideDOM = event.composedPath().includes(internalRef.current);\n        }\n        else {\n            insideDOM =\n                !doc.documentElement.contains(event.target) ||\n                    internalRef.current.contains(event.target);\n        }\n        if (!insideDOM && (disableReactTree || !insideReactTree)) {\n            onClickAway(event);\n        }\n    });\n    const createHandleSynthetic = (event) => {\n        syntheticEventRef.current = true;\n    };\n    React.useEffect(() => {\n        if (touchEvent !== false) {\n            const mappedTouchEvent = mapEventPropToEvent(touchEvent);\n            const doc = ownerDocument(internalRef.current);\n            const handleTouchMove = () => {\n                movedRef.current = true;\n            };\n            doc.addEventListener(mappedTouchEvent, handleClickAway);\n            doc.addEventListener(\"touchmove\", handleTouchMove);\n            return () => {\n                doc.removeEventListener(mappedTouchEvent, handleClickAway);\n                doc.removeEventListener(\"touchmove\", handleTouchMove);\n            };\n        }\n        return undefined;\n    }, [handleClickAway, touchEvent]);\n    React.useEffect(() => {\n        if (mouseEvent !== false) {\n            const mappedMouseEvent = mapEventPropToEvent(mouseEvent);\n            const doc = ownerDocument(internalRef.current);\n            doc.addEventListener(mappedMouseEvent, handleClickAway);\n            return () => {\n                doc.removeEventListener(mappedMouseEvent, handleClickAway);\n            };\n        }\n        return undefined;\n    }, [handleClickAway, mouseEvent]);\n    const listenerProps = {};\n    if (mouseEvent !== false) {\n        listenerProps[mouseEvent] = createHandleSynthetic;\n    }\n    if (touchEvent !== false) {\n        listenerProps[touchEvent] = createHandleSynthetic;\n    }\n    return {\n        ref: handleRef,\n        listenerProps,\n    };\n}"
  }
}