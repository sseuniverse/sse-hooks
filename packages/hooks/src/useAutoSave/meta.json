{
  "$schema": "https://raw.githubusercontent.com/sseuniverse/sse-hooks/refs/heads/main/schema/meta.json",
  "name": "use-auto-save",
  "type": "registry:hook",
  "title": "useAutoSave",
  "description": "Configuration options for the useAutoSave hook.",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [
    "use-callback-ref",
    "use-debounce-callback"
  ],
  "file": {
    "content": "import { useEffect, useRef, useState } from \"react\";\nimport React from \"react\";\n\nexport interface BaseConfig {\n  delay?: number;\n}\n\nexport interface UseAutoSaveReturn<T extends Record<string, any>> {\n  data: T;\n\n  setData: React.Dispatch<React.SetStateAction<T>>;\n\n  onChange: (key: keyof T) => (valueOrEvent: any) => void;\n\n  isSaving: boolean;\n}\n\nexport type ValueOrEvent =\n  | React.ChangeEvent<\n      HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement\n    >\n  | any;\n\nimport { useCallbackRef } from \"./use-callback-ref\";\nimport { useDebounceCallback } from \"./use-debounce-callback\";\n\nexport function useAutoSave<\n  T extends Record<string, any>,\n  K extends keyof T = keyof T,\n>(\n  initialData: T,\n  onSave: (data: Omit<T, K>) => Promise<void> | void,\n  config: BaseConfig & { exclude: readonly K[] },\n): UseAutoSaveReturn<T>;\nexport function useAutoSave<T extends Record<string, any>>(\n  initialData: T,\n  onSave: (data: T) => Promise<void> | void,\n  config?: BaseConfig,\n): UseAutoSaveReturn<T>;\nexport function useAutoSave<\n  T extends Record<string, any>,\n  K extends keyof T = keyof T,\n>(\n  initialData: T,\n  onSave: (data: T | Omit<T, K>) => Promise<void> | void,\n  config: BaseConfig & { exclude?: readonly K[] } = {},\n): UseAutoSaveReturn<T> {\n  const { delay = 1000, exclude = [] } = config;\n\n  const [data, setData] = useState<T>(initialData);\n  const [isSaving, setIsSaving] = useState<boolean>(false);\n\n  const initialRender = useRef<boolean>(true);\n  const isMounted = useRef<boolean>(true);\n  const onSaveRef = useRef(onSave);\n  const excludeRef = useRef(exclude);\n  const saveRequestId = useRef<number>(0);\n\n  const lastSavedStateRef = useRef<string>(\n    JSON.stringify(getCleanPayload(initialData, exclude)),\n  );\n\n  useEffect(() => {\n    onSaveRef.current = onSave;\n    excludeRef.current = exclude;\n  }, [onSave, exclude]);\n\n  useEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  const handleSave = useCallbackRef(async (dataToSave: T) => {\n    const payload = getCleanPayload(dataToSave, excludeRef.current);\n    const payloadString = JSON.stringify(payload);\n\n    if (payloadString === lastSavedStateRef.current) {\n      return;\n    }\n\n    const currentRequestId = ++saveRequestId.current;\n    if (isMounted.current) setIsSaving(true);\n\n    try {\n      await onSaveRef.current(payload as Omit<T, K>);\n\n      if (currentRequestId === saveRequestId.current && isMounted.current) {\n        lastSavedStateRef.current = payloadString;\n      }\n    } catch (error) {\n      console.error(\"Auto-save failed:\", error);\n    } finally {\n      if (currentRequestId === saveRequestId.current && isMounted.current) {\n        setIsSaving(false);\n      }\n    }\n  });\n\n  const debouncedSave = useDebounceCallback(handleSave, delay);\n\n  useEffect(() => {\n    if (initialRender.current) {\n      initialRender.current = false;\n      return;\n    }\n    debouncedSave(data);\n  }, [data, debouncedSave]);\n\n  const onChange = useCallbackRef((key: keyof T) => {\n    return (valueOrEvent: ValueOrEvent) => {\n      let value = valueOrEvent;\n\n      if (\n        valueOrEvent &&\n        typeof valueOrEvent === \"object\" &&\n        \"target\" in valueOrEvent\n      ) {\n        const target = valueOrEvent.target;\n\n        value = target.type === \"checkbox\" ? target.checked : target.value;\n      }\n\n      setData((prev) => ({ ...prev, [key]: value }));\n    };\n  });\n\n  return {\n    data,\n    setData,\n    onChange,\n    isSaving,\n  };\n}\n\nfunction getCleanPayload<T, K extends keyof T>(\n  data: T,\n  keys: readonly K[],\n): Omit<T, K> {\n  if (!keys || keys.length === 0) return data;\n\n  const payload: any = { ...data };\n  keys.forEach((key) => {\n    delete payload[key];\n  });\n  return payload;\n}\n",
    "js": "import { useEffect, useRef, useState } from \"react\";\nimport { useCallbackRef } from \"./use-callback-ref\";\nimport { useDebounceCallback } from \"./use-debounce-callback\";\nexport function useAutoSave(initialData, onSave, config = {}) {\n    const { delay = 1000, exclude = [] } = config;\n    const [data, setData] = useState(initialData);\n    const [isSaving, setIsSaving] = useState(false);\n    const initialRender = useRef(true);\n    const isMounted = useRef(true);\n    const onSaveRef = useRef(onSave);\n    const excludeRef = useRef(exclude);\n    const saveRequestId = useRef(0);\n    const lastSavedStateRef = useRef(JSON.stringify(getCleanPayload(initialData, exclude)));\n    useEffect(() => {\n        onSaveRef.current = onSave;\n        excludeRef.current = exclude;\n    }, [onSave, exclude]);\n    useEffect(() => {\n        isMounted.current = true;\n        return () => {\n            isMounted.current = false;\n        };\n    }, []);\n    const handleSave = useCallbackRef(async (dataToSave) => {\n        const payload = getCleanPayload(dataToSave, excludeRef.current);\n        const payloadString = JSON.stringify(payload);\n        if (payloadString === lastSavedStateRef.current) {\n            return;\n        }\n        const currentRequestId = ++saveRequestId.current;\n        if (isMounted.current)\n            setIsSaving(true);\n        try {\n            await onSaveRef.current(payload);\n            if (currentRequestId === saveRequestId.current && isMounted.current) {\n                lastSavedStateRef.current = payloadString;\n            }\n        }\n        catch (error) {\n            console.error(\"Auto-save failed:\", error);\n        }\n        finally {\n            if (currentRequestId === saveRequestId.current && isMounted.current) {\n                setIsSaving(false);\n            }\n        }\n    });\n    const debouncedSave = useDebounceCallback(handleSave, delay);\n    useEffect(() => {\n        if (initialRender.current) {\n            initialRender.current = false;\n            return;\n        }\n        debouncedSave(data);\n    }, [data, debouncedSave]);\n    const onChange = useCallbackRef((key) => {\n        return (valueOrEvent) => {\n            let value = valueOrEvent;\n            if (valueOrEvent &&\n                typeof valueOrEvent === \"object\" &&\n                \"target\" in valueOrEvent) {\n                const target = valueOrEvent.target;\n                value = target.type === \"checkbox\" ? target.checked : target.value;\n            }\n            setData((prev) => ({ ...prev, [key]: value }));\n        };\n    });\n    return {\n        data,\n        setData,\n        onChange,\n        isSaving,\n    };\n}\nfunction getCleanPayload(data, keys) {\n    if (!keys || keys.length === 0)\n        return data;\n    const payload = { ...data };\n    keys.forEach((key) => {\n        delete payload[key];\n    });\n    return payload;\n}"
  }
}