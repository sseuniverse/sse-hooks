{
  "$schema": "https://raw.githubusercontent.com/sseuniverse/sse-hooks/refs/heads/main/schema/meta.json",
  "name": "use-fork-ref",
  "type": "registry:hook",
  "title": "useForkRef",
  "description": "Merges refs into a single memoized callback ref or `null`. ```tsx const rootRef = React.useRef<Instance>(null); const refFork = useForkRef(rootRef, props.ref); return (   <Root {...props} ref={refFork} /> ); ```",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [],
  "file": {
    "content": "import React from \"react\";\r\n\r\n\r\nexport function useForkRef<Instance>(\r\n  ...refs: Array<React.Ref<Instance> | undefined>\r\n): React.RefCallback<Instance> | null {\r\n  const cleanupRef = React.useRef<() => void>(undefined);\r\n\r\n  const refEffect = React.useCallback((instance: Instance) => {\r\n    const cleanups = refs.map((ref) => {\r\n      if (ref == null) {\r\n        return null;\r\n      }\r\n\r\n      if (typeof ref === \"function\") {\r\n        const refCallback = ref;\r\n        const refCleanup: void | (() => void) = refCallback(instance);\r\n        return typeof refCleanup === \"function\"\r\n          ? refCleanup\r\n          : () => {\r\n              refCallback(null);\r\n            };\r\n      }\r\n\r\n      ref.current = instance;\r\n      return () => {\r\n        ref.current = null;\r\n      };\r\n    });\r\n\r\n    return () => {\r\n      cleanups.forEach((refCleanup) => refCleanup?.());\r\n    };\r\n  }, refs);\r\n\r\n  return React.useMemo(() => {\r\n    if (refs.every((ref) => ref == null)) {\r\n      return null;\r\n    }\r\n\r\n    return (value) => {\r\n      if (cleanupRef.current) {\r\n        cleanupRef.current();\r\n        cleanupRef.current = undefined;\r\n      }\r\n\r\n      if (value != null) {\r\n        cleanupRef.current = refEffect(value);\r\n      }\r\n    };\r\n  }, refs);\r\n}",
    "js": "import React from \"react\";\nexport function useForkRef(...refs) {\n    const cleanupRef = React.useRef(undefined);\n    const refEffect = React.useCallback((instance) => {\n        const cleanups = refs.map((ref) => {\n            if (ref == null) {\n                return null;\n            }\n            if (typeof ref === \"function\") {\n                const refCallback = ref;\n                const refCleanup = refCallback(instance);\n                return typeof refCleanup === \"function\"\n                    ? refCleanup\n                    : () => {\n                        refCallback(null);\n                    };\n            }\n            ref.current = instance;\n            return () => {\n                ref.current = null;\n            };\n        });\n        return () => {\n            cleanups.forEach((refCleanup) => refCleanup?.());\n        };\n    }, refs);\n    return React.useMemo(() => {\n        if (refs.every((ref) => ref == null)) {\n            return null;\n        }\n        return (value) => {\n            if (cleanupRef.current) {\n                cleanupRef.current();\n                cleanupRef.current = undefined;\n            }\n            if (value != null) {\n                cleanupRef.current = refEffect(value);\n            }\n        };\n    }, refs);\n}"
  }
}