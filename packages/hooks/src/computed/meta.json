{
  "$schema": "https://raw.githubusercontent.com/sseuniverse/sse-hooks/refs/heads/main/schema/meta.json",
  "name": "computed",
  "type": "registry:hook",
  "title": "computed",
  "description": "A subscriber bridge that connects the Vue-like Dep system to React's state.",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [],
  "file": {
    "content": "export const extend = Object.assign;\nexport const isArray = Array.isArray;\nexport const isMap = (val: unknown): val is Map<any, any> => val instanceof Map;\n\nexport const isFunction = (val: unknown): val is Function =>\n  typeof val === \"function\";\n\nexport const isSymbol = (val: unknown): val is symbol =>\n  typeof val === \"symbol\";\n\nexport const isObject = (val: unknown): val is Record<any, any> =>\n  val !== null && typeof val === \"object\";\n\nexport const isIntegerKey = (key: any) =>\n  typeof key === \"string\" &&\n  key !== \"NaN\" &&\n  key[0] !== \"-\" &&\n  \"\" + parseInt(key, 10) === key;\n\nexport const __DEV__ = process.env.NODE_ENV !== \"production\";\n\nexport enum EffectFlags {\n  ACTIVE = 1 << 0,\n  RUNNING = 1 << 1,\n  TRACKING = 1 << 2,\n  NOTIFIED = 1 << 3,\n  DIRTY = 1 << 4,\n  ALLOW_RECURSE = 1 << 5,\n  PAUSED = 1 << 6,\n}\n\nexport enum TrackOpTypes {\n  GET = \"get\",\n  HAS = \"has\",\n  ITERATE = \"iterate\",\n}\n\nexport enum TriggerOpTypes {\n  SET = \"set\",\n  ADD = \"add\",\n  DELETE = \"delete\",\n  CLEAR = \"clear\",\n}\n\nexport const ReactiveFlags = {\n  IS_REF: \"__v_isRef\",\n  IS_READONLY: \"__v_isReadonly\",\n  SKIP: \"__v_skip\",\n} as const;\n\nexport let globalVersion = 0;\n\nexport class Link {\n  version: number;\n  nextDep?: Link;\n  prevDep?: Link;\n  nextSub?: Link;\n  prevSub?: Link;\n  prevActiveLink?: Link;\n\n  constructor(\n    public sub: Subscriber,\n    public dep: Dep,\n  ) {\n    this.version = dep.version;\n  }\n}\n\nexport class Dep {\n  version = 0;\n  activeLink?: Link = undefined;\n  subs?: Link = undefined;\n  subsHead?: Link;\n  map?: Map<any, Dep> = undefined;\n  key?: unknown = undefined;\n  sc: number = 0;\n\n  constructor(public computed?: ComputedRefImpl | undefined) {\n    if (__DEV__) {\n      this.subsHead = undefined;\n    }\n  }\n\n  track(debugInfo?: DebuggerEventExtraInfo): Link | undefined {\n    const activeSub = getActiveSub();\n    if (!activeSub || !shouldTrack || activeSub === this.computed) {\n      return;\n    }\n\n    let link = this.activeLink;\n    if (link === undefined || link.sub !== activeSub) {\n      link = this.activeLink = new Link(activeSub, this);\n\n      if (!activeSub.deps) {\n        activeSub.deps = activeSub.depsTail = link;\n      } else {\n        link.prevDep = activeSub.depsTail;\n        activeSub.depsTail!.nextDep = link;\n        activeSub.depsTail = link;\n      }\n\n      addSub(link);\n    } else if (link.version === -1) {\n      link.version = this.version;\n      if (link.nextDep) {\n        const next = link.nextDep;\n        next.prevDep = link.prevDep;\n        if (link.prevDep) link.prevDep.nextDep = next;\n\n        link.prevDep = activeSub.depsTail;\n        link.nextDep = undefined;\n        activeSub.depsTail!.nextDep = link;\n        activeSub.depsTail = link;\n\n        if (activeSub.deps === link) activeSub.deps = next;\n      }\n    }\n\n    if (__DEV__ && activeSub.onTrack) {\n      activeSub.onTrack(extend({ effect: activeSub }, debugInfo));\n    }\n\n    return link;\n  }\n\n  trigger(debugInfo?: DebuggerEventExtraInfo): void {\n    this.version++;\n    globalVersion++;\n    this.notify(debugInfo);\n  }\n\n  notify(debugInfo?: DebuggerEventExtraInfo): void {\n    startBatch();\n    try {\n      for (let link = this.subs; link; link = link.prevSub) {\n        if (link.sub.notify()) {\n          (link.sub as ComputedRefImpl).dep.notify();\n        }\n      }\n    } finally {\n      endBatch();\n    }\n  }\n}\n\nfunction addSub(link: Link) {\n  link.dep.sc++;\n  if (link.sub.flags & EffectFlags.TRACKING) {\n    const computed = link.dep.computed;\n    if (computed && !link.dep.subs) {\n      computed.flags |= EffectFlags.TRACKING | EffectFlags.DIRTY;\n      for (let l = computed.deps; l; l = l.nextDep) {\n        addSub(l);\n      }\n    }\n\n    const currentTail = link.dep.subs;\n    if (currentTail !== link) {\n      link.prevSub = currentTail;\n      if (currentTail) currentTail.nextSub = link;\n    }\n    link.dep.subs = link;\n  }\n}\n\ntype KeyToDepMap = Map<any, Dep>;\nexport const targetMap: WeakMap<object, KeyToDepMap> = new WeakMap();\n\nexport function track(target: object, type: TrackOpTypes, key: unknown): void {\n  const activeSub = getActiveSub();\n  if (shouldTrack && activeSub) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, (depsMap = new Map()));\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, (dep = new Dep()));\n      dep.map = depsMap;\n      dep.key = key;\n    }\n    dep.track({ target, type, key });\n  }\n}\n\nexport interface Subscriber {\n  deps?: Link;\n  depsTail?: Link;\n  flags: EffectFlags;\n  next?: Subscriber;\n  notify(): true | void;\n  onTrack?: (event: DebuggerEvent) => void;\n  onTrigger?: (event: DebuggerEvent) => void;\n}\n\nexport type DebuggerEvent = {\n  effect: Subscriber;\n} & DebuggerEventExtraInfo;\n\nexport type DebuggerEventExtraInfo = {\n  target: object;\n  type: TrackOpTypes | TriggerOpTypes;\n  key: any;\n  newValue?: any;\n  oldValue?: any;\n  oldTarget?: Map<any, any> | Set<any>;\n};\n\nexport interface DebuggerOptions {\n  onTrack?: (event: DebuggerEvent) => void;\n  onTrigger?: (event: DebuggerEvent) => void;\n}\n\nlet activeSub: Subscriber | undefined;\nexport let shouldTrack = true;\nlet batchDepth = 0;\n\nexport function getActiveSub() {\n  return activeSub;\n}\nexport function setActiveSub(sub: Subscriber | undefined) {\n  activeSub = sub;\n}\n\nexport function startBatch() {\n  batchDepth++;\n}\nexport function endBatch() {\n  batchDepth--;\n}\n\nexport function batch(sub: Subscriber, isComputed = false) {}\n\nexport interface Ref<T = any> {\n  value: T;\n}\n\nexport class RefImpl<T> implements Ref<T> {\n  private _value: T;\n  public dep: Dep;\n  public __v_isRef = true;\n\n  constructor(value: T) {\n    this._value = value;\n    this.dep = new Dep();\n  }\n\n  get value() {\n    this.dep.track({ target: this, type: TrackOpTypes.GET, key: \"value\" });\n    return this._value;\n  }\n\n  set value(newVal: T) {\n    if (newVal !== this._value) {\n      this._value = newVal;\n      this.dep.trigger({\n        target: this,\n        type: TriggerOpTypes.SET,\n        key: \"value\",\n        newValue: newVal,\n      });\n    }\n  }\n}\n\nexport function ref<T>(value: T): Ref<T> {\n  return new RefImpl(value);\n}\n\ndeclare const ComputedRefSymbol: unique symbol;\n\ntype BaseComputedRef<T> = Ref<T> & {\n  [ComputedRefSymbol]: true;\n  effect: Subscriber;\n};\n\nexport type ComputedRef<T = any> = BaseComputedRef<T> & {\n  readonly value: T;\n};\n\nexport type ComputedGetter<T> = (oldValue?: T) => T;\nexport type ComputedSetter<T> = (newValue: T) => void;\n\nexport interface WritableComputedOptions<T> {\n  get: ComputedGetter<T>;\n  set: ComputedSetter<T>;\n}\n\nexport function refreshComputed(computed: ComputedRefImpl) {\n  if (computed.flags & EffectFlags.DIRTY) {\n    const prevSub = getActiveSub();\n    setActiveSub(computed);\n    try {\n      for (let link = computed.deps; link; link = link.nextDep) {\n        link.version = -1;\n        link.prevActiveLink = link.prevDep;\n      }\n      const value = computed.fn(computed._value);\n      computed._value = value;\n      computed.flags &= ~EffectFlags.DIRTY;\n    } finally {\n      setActiveSub(prevSub);\n    }\n  }\n}\n\nexport class ComputedRefImpl<T = any> implements Subscriber {\n  _value: any = undefined;\n  readonly dep: Dep = new Dep(this);\n  readonly __v_isRef = true;\n\n  deps?: Link = undefined;\n  depsTail?: Link = undefined;\n  flags: EffectFlags = EffectFlags.DIRTY;\n  globalVersion: number = globalVersion - 1;\n  isSSR: boolean;\n\n  effect: this = this;\n  onTrack?: (event: DebuggerEvent) => void;\n  onTrigger?: (event: DebuggerEvent) => void;\n\n  constructor(\n    public fn: ComputedGetter<T>,\n    private readonly setter: ComputedSetter<T> | undefined,\n    isSSR: boolean,\n  ) {\n    this.isSSR = isSSR;\n  }\n\n  notify(): true | void {\n    this.flags |= EffectFlags.DIRTY;\n    return true;\n  }\n\n  get value(): T {\n    const link = __DEV__\n      ? this.dep.track({ target: this, type: TrackOpTypes.GET, key: \"value\" })\n      : this.dep.track();\n\n    refreshComputed(this);\n\n    if (link) link.version = this.dep.version;\n    return this._value;\n  }\n\n  set value(newValue) {\n    if (this.setter) {\n      this.setter(newValue);\n    } else {\n      console.warn(\"Write operation failed: computed value is readonly\");\n    }\n  }\n}\n\nexport function computed<T>(\n  getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>,\n  debugOptions?: DebuggerOptions,\n  isSSR = false,\n) {\n  let getter: ComputedGetter<T>;\n  let setter: ComputedSetter<T> | undefined;\n\n  if (isFunction(getterOrOptions)) {\n    getter = getterOrOptions;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n\n  const cRef = new ComputedRefImpl(getter, setter, isSSR);\n  return cRef as any;\n}\n\nimport { useEffect, useMemo, useRef, useState } from \"react\";\n\nclass ReactSubscriber implements Subscriber {\n  deps?: Link;\n  depsTail?: Link;\n  flags: EffectFlags = EffectFlags.TRACKING;\n\n  constructor(private triggerUpdate: () => void) {}\n\n  notify() {\n    this.triggerUpdate();\n  }\n}\n\nexport function useReactive<T>(refObj: Ref<T>): T {\n  const [, setTick] = useState(0);\n  const forceUpdate = () => setTick((t) => t + 1);\n  const subscriberRef = useRef<ReactSubscriber | null>(null);\n\n  if (!subscriberRef.current) {\n    subscriberRef.current = new ReactSubscriber(forceUpdate);\n  }\n\n  const sub = subscriberRef.current!;\n  const prevSub = getActiveSub();\n  setActiveSub(sub);\n  const value = refObj.value;\n  setActiveSub(prevSub);\n\n  useEffect(() => {\n    return () => {};\n  }, []);\n\n  return value;\n}\n\nexport function useComputed<T>(getter: () => T, deps: any[] = []): T {\n  const cRef = useMemo(() => computed(getter), deps);\n  return useReactive(cRef);\n}\n",
    "js": "export const extend = Object.assign;\nexport const isArray = Array.isArray;\nexport const isMap = (val) => val instanceof Map;\nexport const isFunction = (val) => typeof val === \"function\";\nexport const isSymbol = (val) => typeof val === \"symbol\";\nexport const isObject = (val) => val !== null && typeof val === \"object\";\nexport const isIntegerKey = (key) => typeof key === \"string\" &&\n    key !== \"NaN\" &&\n    key[0] !== \"-\" &&\n    \"\" + parseInt(key, 10) === key;\nexport const __DEV__ = process.env.NODE_ENV !== \"production\";\nexport var EffectFlags;\n(function (EffectFlags) {\n    EffectFlags[EffectFlags[\"ACTIVE\"] = 1] = \"ACTIVE\";\n    EffectFlags[EffectFlags[\"RUNNING\"] = 2] = \"RUNNING\";\n    EffectFlags[EffectFlags[\"TRACKING\"] = 4] = \"TRACKING\";\n    EffectFlags[EffectFlags[\"NOTIFIED\"] = 8] = \"NOTIFIED\";\n    EffectFlags[EffectFlags[\"DIRTY\"] = 16] = \"DIRTY\";\n    EffectFlags[EffectFlags[\"ALLOW_RECURSE\"] = 32] = \"ALLOW_RECURSE\";\n    EffectFlags[EffectFlags[\"PAUSED\"] = 64] = \"PAUSED\";\n})(EffectFlags || (EffectFlags = {}));\nexport var TrackOpTypes;\n(function (TrackOpTypes) {\n    TrackOpTypes[\"GET\"] = \"get\";\n    TrackOpTypes[\"HAS\"] = \"has\";\n    TrackOpTypes[\"ITERATE\"] = \"iterate\";\n})(TrackOpTypes || (TrackOpTypes = {}));\nexport var TriggerOpTypes;\n(function (TriggerOpTypes) {\n    TriggerOpTypes[\"SET\"] = \"set\";\n    TriggerOpTypes[\"ADD\"] = \"add\";\n    TriggerOpTypes[\"DELETE\"] = \"delete\";\n    TriggerOpTypes[\"CLEAR\"] = \"clear\";\n})(TriggerOpTypes || (TriggerOpTypes = {}));\nexport const ReactiveFlags = {\n    IS_REF: \"__v_isRef\",\n    IS_READONLY: \"__v_isReadonly\",\n    SKIP: \"__v_skip\",\n};\nexport let globalVersion = 0;\nexport class Link {\n    sub;\n    dep;\n    version;\n    nextDep;\n    prevDep;\n    nextSub;\n    prevSub;\n    prevActiveLink;\n    constructor(sub, dep) {\n        this.sub = sub;\n        this.dep = dep;\n        this.version = dep.version;\n    }\n}\nexport class Dep {\n    computed;\n    version = 0;\n    activeLink = undefined;\n    subs = undefined;\n    subsHead;\n    map = undefined;\n    key = undefined;\n    sc = 0;\n    constructor(computed) {\n        this.computed = computed;\n        if (__DEV__) {\n            this.subsHead = undefined;\n        }\n    }\n    track(debugInfo) {\n        const activeSub = getActiveSub();\n        if (!activeSub || !shouldTrack || activeSub === this.computed) {\n            return;\n        }\n        let link = this.activeLink;\n        if (link === undefined || link.sub !== activeSub) {\n            link = this.activeLink = new Link(activeSub, this);\n            if (!activeSub.deps) {\n                activeSub.deps = activeSub.depsTail = link;\n            }\n            else {\n                link.prevDep = activeSub.depsTail;\n                activeSub.depsTail.nextDep = link;\n                activeSub.depsTail = link;\n            }\n            addSub(link);\n        }\n        else if (link.version === -1) {\n            link.version = this.version;\n            if (link.nextDep) {\n                const next = link.nextDep;\n                next.prevDep = link.prevDep;\n                if (link.prevDep)\n                    link.prevDep.nextDep = next;\n                link.prevDep = activeSub.depsTail;\n                link.nextDep = undefined;\n                activeSub.depsTail.nextDep = link;\n                activeSub.depsTail = link;\n                if (activeSub.deps === link)\n                    activeSub.deps = next;\n            }\n        }\n        if (__DEV__ && activeSub.onTrack) {\n            activeSub.onTrack(extend({ effect: activeSub }, debugInfo));\n        }\n        return link;\n    }\n    trigger(debugInfo) {\n        this.version++;\n        globalVersion++;\n        this.notify(debugInfo);\n    }\n    notify(debugInfo) {\n        startBatch();\n        try {\n            for (let link = this.subs; link; link = link.prevSub) {\n                if (link.sub.notify()) {\n                    link.sub.dep.notify();\n                }\n            }\n        }\n        finally {\n            endBatch();\n        }\n    }\n}\nfunction addSub(link) {\n    link.dep.sc++;\n    if (link.sub.flags & EffectFlags.TRACKING) {\n        const computed = link.dep.computed;\n        if (computed && !link.dep.subs) {\n            computed.flags |= EffectFlags.TRACKING | EffectFlags.DIRTY;\n            for (let l = computed.deps; l; l = l.nextDep) {\n                addSub(l);\n            }\n        }\n        const currentTail = link.dep.subs;\n        if (currentTail !== link) {\n            link.prevSub = currentTail;\n            if (currentTail)\n                currentTail.nextSub = link;\n        }\n        link.dep.subs = link;\n    }\n}\nexport const targetMap = new WeakMap();\nexport function track(target, type, key) {\n    const activeSub = getActiveSub();\n    if (shouldTrack && activeSub) {\n        let depsMap = targetMap.get(target);\n        if (!depsMap) {\n            targetMap.set(target, (depsMap = new Map()));\n        }\n        let dep = depsMap.get(key);\n        if (!dep) {\n            depsMap.set(key, (dep = new Dep()));\n            dep.map = depsMap;\n            dep.key = key;\n        }\n        dep.track({ target, type, key });\n    }\n}\nlet activeSub;\nexport let shouldTrack = true;\nlet batchDepth = 0;\nexport function getActiveSub() {\n    return activeSub;\n}\nexport function setActiveSub(sub) {\n    activeSub = sub;\n}\nexport function startBatch() {\n    batchDepth++;\n}\nexport function endBatch() {\n    batchDepth--;\n}\nexport function batch(sub, isComputed = false) { }\nexport class RefImpl {\n    _value;\n    dep;\n    __v_isRef = true;\n    constructor(value) {\n        this._value = value;\n        this.dep = new Dep();\n    }\n    get value() {\n        this.dep.track({ target: this, type: TrackOpTypes.GET, key: \"value\" });\n        return this._value;\n    }\n    set value(newVal) {\n        if (newVal !== this._value) {\n            this._value = newVal;\n            this.dep.trigger({\n                target: this,\n                type: TriggerOpTypes.SET,\n                key: \"value\",\n                newValue: newVal,\n            });\n        }\n    }\n}\nexport function ref(value) {\n    return new RefImpl(value);\n}\nexport function refreshComputed(computed) {\n    if (computed.flags & EffectFlags.DIRTY) {\n        const prevSub = getActiveSub();\n        setActiveSub(computed);\n        try {\n            for (let link = computed.deps; link; link = link.nextDep) {\n                link.version = -1;\n                link.prevActiveLink = link.prevDep;\n            }\n            const value = computed.fn(computed._value);\n            computed._value = value;\n            computed.flags &= ~EffectFlags.DIRTY;\n        }\n        finally {\n            setActiveSub(prevSub);\n        }\n    }\n}\nexport class ComputedRefImpl {\n    fn;\n    setter;\n    _value = undefined;\n    dep = new Dep(this);\n    __v_isRef = true;\n    deps = undefined;\n    depsTail = undefined;\n    flags = EffectFlags.DIRTY;\n    globalVersion = globalVersion - 1;\n    isSSR;\n    effect = this;\n    onTrack;\n    onTrigger;\n    constructor(fn, setter, isSSR) {\n        this.fn = fn;\n        this.setter = setter;\n        this.isSSR = isSSR;\n    }\n    notify() {\n        this.flags |= EffectFlags.DIRTY;\n        return true;\n    }\n    get value() {\n        const link = __DEV__\n            ? this.dep.track({ target: this, type: TrackOpTypes.GET, key: \"value\" })\n            : this.dep.track();\n        refreshComputed(this);\n        if (link)\n            link.version = this.dep.version;\n        return this._value;\n    }\n    set value(newValue) {\n        if (this.setter) {\n            this.setter(newValue);\n        }\n        else {\n            console.warn(\"Write operation failed: computed value is readonly\");\n        }\n    }\n}\nexport function computed(getterOrOptions, debugOptions, isSSR = false) {\n    let getter;\n    let setter;\n    if (isFunction(getterOrOptions)) {\n        getter = getterOrOptions;\n    }\n    else {\n        getter = getterOrOptions.get;\n        setter = getterOrOptions.set;\n    }\n    const cRef = new ComputedRefImpl(getter, setter, isSSR);\n    return cRef;\n}\nimport { useEffect, useMemo, useRef, useState } from \"react\";\nclass ReactSubscriber {\n    triggerUpdate;\n    deps;\n    depsTail;\n    flags = EffectFlags.TRACKING;\n    constructor(triggerUpdate) {\n        this.triggerUpdate = triggerUpdate;\n    }\n    notify() {\n        this.triggerUpdate();\n    }\n}\nexport function useReactive(refObj) {\n    const [, setTick] = useState(0);\n    const forceUpdate = () => setTick((t) => t + 1);\n    const subscriberRef = useRef(null);\n    if (!subscriberRef.current) {\n        subscriberRef.current = new ReactSubscriber(forceUpdate);\n    }\n    const sub = subscriberRef.current;\n    const prevSub = getActiveSub();\n    setActiveSub(sub);\n    const value = refObj.value;\n    setActiveSub(prevSub);\n    useEffect(() => {\n        return () => { };\n    }, []);\n    return value;\n}\nexport function useComputed(getter, deps = []) {\n    const cRef = useMemo(() => computed(getter), deps);\n    return useReactive(cRef);\n}"
  }
}