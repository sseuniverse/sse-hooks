{
  "$schema": "https://raw.githubusercontent.com/sseuniverse/sse-hooks/refs/heads/main/schema/meta.json",
  "name": "computed",
  "type": "registry:hook",
  "title": "computed",
  "description": "A subscriber bridge that connects the Vue-like Dep system to React's state.",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [],
  "file": {
    "content": "export const extend = Object.assign;\r\nexport const isArray = Array.isArray;\r\nexport const isMap = (val: unknown): val is Map<any, any> => val instanceof Map;\r\n\r\nexport const isFunction = (val: unknown): val is Function =>\r\n  typeof val === \"function\";\r\n\r\nexport const isSymbol = (val: unknown): val is symbol =>\r\n  typeof val === \"symbol\";\r\n\r\nexport const isObject = (val: unknown): val is Record<any, any> =>\r\n  val !== null && typeof val === \"object\";\r\n\r\nexport const isIntegerKey = (key: any) =>\r\n  typeof key === \"string\" &&\r\n  key !== \"NaN\" &&\r\n  key[0] !== \"-\" &&\r\n  \"\" + parseInt(key, 10) === key;\r\n\r\nexport const __DEV__ = process.env.NODE_ENV !== \"production\";\r\n\nexport enum EffectFlags {\r\n  ACTIVE = 1 << 0,\r\n  RUNNING = 1 << 1,\r\n  TRACKING = 1 << 2,\r\n  NOTIFIED = 1 << 3,\r\n  DIRTY = 1 << 4,\r\n  ALLOW_RECURSE = 1 << 5,\r\n  PAUSED = 1 << 6,\r\n}\r\n\r\nexport enum TrackOpTypes {\r\n  GET = \"get\",\r\n  HAS = \"has\",\r\n  ITERATE = \"iterate\",\r\n}\r\n\r\nexport enum TriggerOpTypes {\r\n  SET = \"set\",\r\n  ADD = \"add\",\r\n  DELETE = \"delete\",\r\n  CLEAR = \"clear\",\r\n}\r\n\r\nexport const ReactiveFlags = {\r\n  IS_REF: \"__v_isRef\",\r\n  IS_READONLY: \"__v_isReadonly\",\r\n  SKIP: \"__v_skip\",\r\n} as const;\r\n\n\n\n\n\nexport let globalVersion = 0;\r\n\r\nexport class Link {\r\n  version: number;\r\n  nextDep?: Link;\r\n  prevDep?: Link;\r\n  nextSub?: Link;\r\n  prevSub?: Link;\r\n  prevActiveLink?: Link;\r\n\r\n  constructor(\r\n    public sub: Subscriber,\r\n    public dep: Dep,\r\n  ) {\r\n    this.version = dep.version;\r\n  }\r\n}\r\n\r\nexport class Dep {\r\n  version = 0;\r\n  activeLink?: Link = undefined;\r\n  subs?: Link = undefined;\r\n  subsHead?: Link;\r\n  map?: Map<any, Dep> = undefined;\r\n  key?: unknown = undefined;\r\n  sc: number = 0;\r\n\r\n  constructor(public computed?: ComputedRefImpl | undefined) {\r\n    if (__DEV__) {\r\n      this.subsHead = undefined;\r\n    }\r\n  }\r\n\r\n  track(debugInfo?: DebuggerEventExtraInfo): Link | undefined {\r\n    const activeSub = getActiveSub();\r\n    if (!activeSub || !shouldTrack || activeSub === this.computed) {\r\n      return;\r\n    }\r\n\r\n    let link = this.activeLink;\r\n    if (link === undefined || link.sub !== activeSub) {\r\n      link = this.activeLink = new Link(activeSub, this);\r\n\r\n      if (!activeSub.deps) {\r\n        activeSub.deps = activeSub.depsTail = link;\r\n      } else {\r\n        link.prevDep = activeSub.depsTail;\r\n        activeSub.depsTail!.nextDep = link;\r\n        activeSub.depsTail = link;\r\n      }\r\n\r\n      addSub(link);\r\n    } else if (link.version === -1) {\r\n      link.version = this.version;\r\n      if (link.nextDep) {\r\n        const next = link.nextDep;\r\n        next.prevDep = link.prevDep;\r\n        if (link.prevDep) link.prevDep.nextDep = next;\r\n\r\n        link.prevDep = activeSub.depsTail;\r\n        link.nextDep = undefined;\r\n        activeSub.depsTail!.nextDep = link;\r\n        activeSub.depsTail = link;\r\n\r\n        if (activeSub.deps === link) activeSub.deps = next;\r\n      }\r\n    }\r\n\r\n    if (__DEV__ && activeSub.onTrack) {\r\n      activeSub.onTrack(extend({ effect: activeSub }, debugInfo));\r\n    }\r\n\r\n    return link;\r\n  }\r\n\r\n  trigger(debugInfo?: DebuggerEventExtraInfo): void {\r\n    this.version++;\r\n    globalVersion++;\r\n    this.notify(debugInfo);\r\n  }\r\n\r\n  notify(debugInfo?: DebuggerEventExtraInfo): void {\r\n    startBatch();\r\n    try {\r\n      for (let link = this.subs; link; link = link.prevSub) {\r\n        if (link.sub.notify()) {\r\n          (link.sub as ComputedRefImpl).dep.notify();\r\n        }\r\n      }\r\n    } finally {\r\n      endBatch();\r\n    }\r\n  }\r\n}\r\n\r\nfunction addSub(link: Link) {\r\n  link.dep.sc++;\r\n  if (link.sub.flags & EffectFlags.TRACKING) {\r\n    const computed = link.dep.computed;\r\n    if (computed && !link.dep.subs) {\r\n      computed.flags |= EffectFlags.TRACKING | EffectFlags.DIRTY;\r\n      for (let l = computed.deps; l; l = l.nextDep) {\r\n        addSub(l);\r\n      }\r\n    }\r\n\r\n    const currentTail = link.dep.subs;\r\n    if (currentTail !== link) {\r\n      link.prevSub = currentTail;\r\n      if (currentTail) currentTail.nextSub = link;\r\n    }\r\n    link.dep.subs = link;\r\n  }\r\n}\r\n\r\n\r\ntype KeyToDepMap = Map<any, Dep>;\r\nexport const targetMap: WeakMap<object, KeyToDepMap> = new WeakMap();\r\n\r\nexport function track(target: object, type: TrackOpTypes, key: unknown): void {\r\n  const activeSub = getActiveSub();\r\n  if (shouldTrack && activeSub) {\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n      targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n      depsMap.set(key, (dep = new Dep()));\r\n      dep.map = depsMap;\r\n      dep.key = key;\r\n    }\r\n    dep.track({ target, type, key });\r\n  }\r\n}\r\n\nexport interface Subscriber {\r\n  deps?: Link;\r\n  depsTail?: Link;\r\n  flags: EffectFlags;\r\n  next?: Subscriber;\r\n  notify(): true | void;\r\n  onTrack?: (event: DebuggerEvent) => void;\r\n  onTrigger?: (event: DebuggerEvent) => void;\r\n}\r\n\r\nexport type DebuggerEvent = {\r\n  effect: Subscriber;\r\n} & DebuggerEventExtraInfo;\r\n\r\nexport type DebuggerEventExtraInfo = {\r\n  target: object;\r\n  type: TrackOpTypes | TriggerOpTypes;\r\n  key: any;\r\n  newValue?: any;\r\n  oldValue?: any;\r\n  oldTarget?: Map<any, any> | Set<any>;\r\n};\r\n\r\nexport interface DebuggerOptions {\r\n  onTrack?: (event: DebuggerEvent) => void;\r\n  onTrigger?: (event: DebuggerEvent) => void;\r\n}\r\n\r\n\r\nlet activeSub: Subscriber | undefined;\r\nexport let shouldTrack = true;\r\nlet batchDepth = 0;\r\n\r\nexport function getActiveSub() {\r\n  return activeSub;\r\n}\r\nexport function setActiveSub(sub: Subscriber | undefined) {\r\n  activeSub = sub;\r\n}\r\n\r\nexport function startBatch() {\r\n  batchDepth++;\r\n}\r\nexport function endBatch() {\r\n  batchDepth--;\r\n}\r\n\r\nexport function batch(sub: Subscriber, isComputed = false) {\r\n  \r\n}\r\n\n\n\n\n\nexport interface Ref<T = any> {\r\n  value: T;\r\n}\r\n\r\nexport class RefImpl<T> implements Ref<T> {\r\n  private _value: T;\r\n  public dep: Dep;\r\n  public __v_isRef = true;\r\n\r\n  constructor(value: T) {\r\n    this._value = value;\r\n    this.dep = new Dep();\r\n  }\r\n\r\n  get value() {\r\n    this.dep.track({ target: this, type: TrackOpTypes.GET, key: \"value\" });\r\n    return this._value;\r\n  }\r\n\r\n  set value(newVal: T) {\r\n    if (newVal !== this._value) {\r\n      this._value = newVal;\r\n      this.dep.trigger({\r\n        target: this,\r\n        type: TriggerOpTypes.SET,\r\n        key: \"value\",\r\n        newValue: newVal,\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport function ref<T>(value: T): Ref<T> {\r\n  return new RefImpl(value);\r\n}\r\n\ndeclare const ComputedRefSymbol: unique symbol;\r\n\r\ntype BaseComputedRef<T> = Ref<T> & {\r\n  [ComputedRefSymbol]: true;\r\n  effect: Subscriber;\r\n};\r\n\r\nexport type ComputedRef<T = any> = BaseComputedRef<T> & {\r\n  readonly value: T;\r\n};\r\n\r\nexport type ComputedGetter<T> = (oldValue?: T) => T;\r\nexport type ComputedSetter<T> = (newValue: T) => void;\r\n\r\nexport interface WritableComputedOptions<T> {\r\n  get: ComputedGetter<T>;\r\n  set: ComputedSetter<T>;\r\n}\r\n\r\nexport function refreshComputed(computed: ComputedRefImpl) {\r\n  if (computed.flags & EffectFlags.DIRTY) {\r\n    const prevSub = getActiveSub();\r\n    setActiveSub(computed);\r\n    try {\r\n      for (let link = computed.deps; link; link = link.nextDep) {\r\n        link.version = -1;\r\n        link.prevActiveLink = link.prevDep;\r\n      }\r\n      const value = computed.fn(computed._value);\r\n      computed._value = value;\r\n      computed.flags &= ~EffectFlags.DIRTY;\r\n    } finally {\r\n      setActiveSub(prevSub);\r\n    }\r\n  }\r\n}\r\n\r\nexport class ComputedRefImpl<T = any> implements Subscriber {\r\n  _value: any = undefined;\r\n  readonly dep: Dep = new Dep(this);\r\n  readonly __v_isRef = true;\r\n\r\n  deps?: Link = undefined;\r\n  depsTail?: Link = undefined;\r\n  flags: EffectFlags = EffectFlags.DIRTY;\r\n  globalVersion: number = globalVersion - 1;\r\n  isSSR: boolean;\r\n\r\n  effect: this = this;\r\n  onTrack?: (event: DebuggerEvent) => void;\r\n  onTrigger?: (event: DebuggerEvent) => void;\r\n\r\n  constructor(\r\n    public fn: ComputedGetter<T>,\r\n    private readonly setter: ComputedSetter<T> | undefined,\r\n    isSSR: boolean,\r\n  ) {\r\n    this.isSSR = isSSR;\r\n  }\r\n\r\n  notify(): true | void {\r\n    this.flags |= EffectFlags.DIRTY;\r\n    return true;\r\n  }\r\n\r\n  get value(): T {\r\n    const link = __DEV__\r\n      ? this.dep.track({ target: this, type: TrackOpTypes.GET, key: \"value\" })\r\n      : this.dep.track();\r\n\r\n    refreshComputed(this);\r\n\r\n    if (link) link.version = this.dep.version;\r\n    return this._value;\r\n  }\r\n\r\n  set value(newValue) {\r\n    if (this.setter) {\r\n      this.setter(newValue);\r\n    } else {\r\n      console.warn(\"Write operation failed: computed value is readonly\");\r\n    }\r\n  }\r\n}\r\n\r\nexport function computed<T>(\r\n  getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>,\r\n  debugOptions?: DebuggerOptions,\r\n  isSSR = false,\r\n) {\r\n  let getter: ComputedGetter<T>;\r\n  let setter: ComputedSetter<T> | undefined;\r\n\r\n  if (isFunction(getterOrOptions)) {\r\n    getter = getterOrOptions;\r\n  } else {\r\n    getter = getterOrOptions.get;\r\n    setter = getterOrOptions.set;\r\n  }\r\n\r\n  const cRef = new ComputedRefImpl(getter, setter, isSSR);\r\n  return cRef as any;\r\n}\r\n\n\n\n\nimport { useEffect, useMemo, useRef, useState } from \"react\";\r\n\n\n\n\n\n\r\nclass ReactSubscriber implements Subscriber {\r\n  deps?: Link;\r\n  depsTail?: Link;\r\n  flags: EffectFlags = EffectFlags.TRACKING;\r\n\r\n  constructor(private triggerUpdate: () => void) {}\r\n\r\n  notify() {\r\n    \r\n    this.triggerUpdate();\r\n  }\r\n}\r\n\r\nexport function useReactive<T>(refObj: Ref<T>): T {\r\n  const [, setTick] = useState(0);\r\n  const forceUpdate = () => setTick((t) => t + 1);\r\n  const subscriberRef = useRef<ReactSubscriber | null>(null);\r\n\r\n  if (!subscriberRef.current) {\r\n    subscriberRef.current = new ReactSubscriber(forceUpdate);\r\n  }\r\n\r\n  const sub = subscriberRef.current!;\r\n  const prevSub = getActiveSub();\r\n  setActiveSub(sub);\r\n  const value = refObj.value;\r\n  setActiveSub(prevSub);\r\n\r\n  useEffect(() => {\r\n    return () => {};\r\n  }, []);\r\n\r\n  return value;\r\n}\r\n\r\nexport function useComputed<T>(getter: () => T, deps: any[] = []): T {\r\n  const cRef = useMemo(() => computed(getter), deps);\r\n  return useReactive(cRef);\r\n}",
    "js": "export const extend = Object.assign;\nexport const isArray = Array.isArray;\nexport const isMap = (val) => val instanceof Map;\nexport const isFunction = (val) => typeof val === \"function\";\nexport const isSymbol = (val) => typeof val === \"symbol\";\nexport const isObject = (val) => val !== null && typeof val === \"object\";\nexport const isIntegerKey = (key) => typeof key === \"string\" &&\n    key !== \"NaN\" &&\n    key[0] !== \"-\" &&\n    \"\" + parseInt(key, 10) === key;\nexport const __DEV__ = process.env.NODE_ENV !== \"production\";\nexport var EffectFlags;\n(function (EffectFlags) {\n    EffectFlags[EffectFlags[\"ACTIVE\"] = 1] = \"ACTIVE\";\n    EffectFlags[EffectFlags[\"RUNNING\"] = 2] = \"RUNNING\";\n    EffectFlags[EffectFlags[\"TRACKING\"] = 4] = \"TRACKING\";\n    EffectFlags[EffectFlags[\"NOTIFIED\"] = 8] = \"NOTIFIED\";\n    EffectFlags[EffectFlags[\"DIRTY\"] = 16] = \"DIRTY\";\n    EffectFlags[EffectFlags[\"ALLOW_RECURSE\"] = 32] = \"ALLOW_RECURSE\";\n    EffectFlags[EffectFlags[\"PAUSED\"] = 64] = \"PAUSED\";\n})(EffectFlags || (EffectFlags = {}));\nexport var TrackOpTypes;\n(function (TrackOpTypes) {\n    TrackOpTypes[\"GET\"] = \"get\";\n    TrackOpTypes[\"HAS\"] = \"has\";\n    TrackOpTypes[\"ITERATE\"] = \"iterate\";\n})(TrackOpTypes || (TrackOpTypes = {}));\nexport var TriggerOpTypes;\n(function (TriggerOpTypes) {\n    TriggerOpTypes[\"SET\"] = \"set\";\n    TriggerOpTypes[\"ADD\"] = \"add\";\n    TriggerOpTypes[\"DELETE\"] = \"delete\";\n    TriggerOpTypes[\"CLEAR\"] = \"clear\";\n})(TriggerOpTypes || (TriggerOpTypes = {}));\nexport const ReactiveFlags = {\n    IS_REF: \"__v_isRef\",\n    IS_READONLY: \"__v_isReadonly\",\n    SKIP: \"__v_skip\",\n};\nexport let globalVersion = 0;\nexport class Link {\n    sub;\n    dep;\n    version;\n    nextDep;\n    prevDep;\n    nextSub;\n    prevSub;\n    prevActiveLink;\n    constructor(sub, dep) {\n        this.sub = sub;\n        this.dep = dep;\n        this.version = dep.version;\n    }\n}\nexport class Dep {\n    computed;\n    version = 0;\n    activeLink = undefined;\n    subs = undefined;\n    subsHead;\n    map = undefined;\n    key = undefined;\n    sc = 0;\n    constructor(computed) {\n        this.computed = computed;\n        if (__DEV__) {\n            this.subsHead = undefined;\n        }\n    }\n    track(debugInfo) {\n        const activeSub = getActiveSub();\n        if (!activeSub || !shouldTrack || activeSub === this.computed) {\n            return;\n        }\n        let link = this.activeLink;\n        if (link === undefined || link.sub !== activeSub) {\n            link = this.activeLink = new Link(activeSub, this);\n            if (!activeSub.deps) {\n                activeSub.deps = activeSub.depsTail = link;\n            }\n            else {\n                link.prevDep = activeSub.depsTail;\n                activeSub.depsTail.nextDep = link;\n                activeSub.depsTail = link;\n            }\n            addSub(link);\n        }\n        else if (link.version === -1) {\n            link.version = this.version;\n            if (link.nextDep) {\n                const next = link.nextDep;\n                next.prevDep = link.prevDep;\n                if (link.prevDep)\n                    link.prevDep.nextDep = next;\n                link.prevDep = activeSub.depsTail;\n                link.nextDep = undefined;\n                activeSub.depsTail.nextDep = link;\n                activeSub.depsTail = link;\n                if (activeSub.deps === link)\n                    activeSub.deps = next;\n            }\n        }\n        if (__DEV__ && activeSub.onTrack) {\n            activeSub.onTrack(extend({ effect: activeSub }, debugInfo));\n        }\n        return link;\n    }\n    trigger(debugInfo) {\n        this.version++;\n        globalVersion++;\n        this.notify(debugInfo);\n    }\n    notify(debugInfo) {\n        startBatch();\n        try {\n            for (let link = this.subs; link; link = link.prevSub) {\n                if (link.sub.notify()) {\n                    link.sub.dep.notify();\n                }\n            }\n        }\n        finally {\n            endBatch();\n        }\n    }\n}\nfunction addSub(link) {\n    link.dep.sc++;\n    if (link.sub.flags & EffectFlags.TRACKING) {\n        const computed = link.dep.computed;\n        if (computed && !link.dep.subs) {\n            computed.flags |= EffectFlags.TRACKING | EffectFlags.DIRTY;\n            for (let l = computed.deps; l; l = l.nextDep) {\n                addSub(l);\n            }\n        }\n        const currentTail = link.dep.subs;\n        if (currentTail !== link) {\n            link.prevSub = currentTail;\n            if (currentTail)\n                currentTail.nextSub = link;\n        }\n        link.dep.subs = link;\n    }\n}\nexport const targetMap = new WeakMap();\nexport function track(target, type, key) {\n    const activeSub = getActiveSub();\n    if (shouldTrack && activeSub) {\n        let depsMap = targetMap.get(target);\n        if (!depsMap) {\n            targetMap.set(target, (depsMap = new Map()));\n        }\n        let dep = depsMap.get(key);\n        if (!dep) {\n            depsMap.set(key, (dep = new Dep()));\n            dep.map = depsMap;\n            dep.key = key;\n        }\n        dep.track({ target, type, key });\n    }\n}\nlet activeSub;\nexport let shouldTrack = true;\nlet batchDepth = 0;\nexport function getActiveSub() {\n    return activeSub;\n}\nexport function setActiveSub(sub) {\n    activeSub = sub;\n}\nexport function startBatch() {\n    batchDepth++;\n}\nexport function endBatch() {\n    batchDepth--;\n}\nexport function batch(sub, isComputed = false) {\n}\nexport class RefImpl {\n    _value;\n    dep;\n    __v_isRef = true;\n    constructor(value) {\n        this._value = value;\n        this.dep = new Dep();\n    }\n    get value() {\n        this.dep.track({ target: this, type: TrackOpTypes.GET, key: \"value\" });\n        return this._value;\n    }\n    set value(newVal) {\n        if (newVal !== this._value) {\n            this._value = newVal;\n            this.dep.trigger({\n                target: this,\n                type: TriggerOpTypes.SET,\n                key: \"value\",\n                newValue: newVal,\n            });\n        }\n    }\n}\nexport function ref(value) {\n    return new RefImpl(value);\n}\nexport function refreshComputed(computed) {\n    if (computed.flags & EffectFlags.DIRTY) {\n        const prevSub = getActiveSub();\n        setActiveSub(computed);\n        try {\n            for (let link = computed.deps; link; link = link.nextDep) {\n                link.version = -1;\n                link.prevActiveLink = link.prevDep;\n            }\n            const value = computed.fn(computed._value);\n            computed._value = value;\n            computed.flags &= ~EffectFlags.DIRTY;\n        }\n        finally {\n            setActiveSub(prevSub);\n        }\n    }\n}\nexport class ComputedRefImpl {\n    fn;\n    setter;\n    _value = undefined;\n    dep = new Dep(this);\n    __v_isRef = true;\n    deps = undefined;\n    depsTail = undefined;\n    flags = EffectFlags.DIRTY;\n    globalVersion = globalVersion - 1;\n    isSSR;\n    effect = this;\n    onTrack;\n    onTrigger;\n    constructor(fn, setter, isSSR) {\n        this.fn = fn;\n        this.setter = setter;\n        this.isSSR = isSSR;\n    }\n    notify() {\n        this.flags |= EffectFlags.DIRTY;\n        return true;\n    }\n    get value() {\n        const link = __DEV__\n            ? this.dep.track({ target: this, type: TrackOpTypes.GET, key: \"value\" })\n            : this.dep.track();\n        refreshComputed(this);\n        if (link)\n            link.version = this.dep.version;\n        return this._value;\n    }\n    set value(newValue) {\n        if (this.setter) {\n            this.setter(newValue);\n        }\n        else {\n            console.warn(\"Write operation failed: computed value is readonly\");\n        }\n    }\n}\nexport function computed(getterOrOptions, debugOptions, isSSR = false) {\n    let getter;\n    let setter;\n    if (isFunction(getterOrOptions)) {\n        getter = getterOrOptions;\n    }\n    else {\n        getter = getterOrOptions.get;\n        setter = getterOrOptions.set;\n    }\n    const cRef = new ComputedRefImpl(getter, setter, isSSR);\n    return cRef;\n}\nimport { useEffect, useMemo, useRef, useState } from \"react\";\nclass ReactSubscriber {\n    triggerUpdate;\n    deps;\n    depsTail;\n    flags = EffectFlags.TRACKING;\n    constructor(triggerUpdate) {\n        this.triggerUpdate = triggerUpdate;\n    }\n    notify() {\n        this.triggerUpdate();\n    }\n}\nexport function useReactive(refObj) {\n    const [, setTick] = useState(0);\n    const forceUpdate = () => setTick((t) => t + 1);\n    const subscriberRef = useRef(null);\n    if (!subscriberRef.current) {\n        subscriberRef.current = new ReactSubscriber(forceUpdate);\n    }\n    const sub = subscriberRef.current;\n    const prevSub = getActiveSub();\n    setActiveSub(sub);\n    const value = refObj.value;\n    setActiveSub(prevSub);\n    useEffect(() => {\n        return () => { };\n    }, []);\n    return value;\n}\nexport function useComputed(getter, deps = []) {\n    const cRef = useMemo(() => computed(getter), deps);\n    return useReactive(cRef);\n}"
  }
}