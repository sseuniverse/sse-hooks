{
  "$schema": "https://raw.githubusercontent.com/sseuniverse/sse-hooks/refs/heads/main/schema/meta.json",
  "name": "use-fetch",
  "type": "registry:hook",
  "title": "useFetch",
  "description": "Options for customizing the behavior of the useFetch hook. Extends the standard [`RequestInit`](https://developer.mozilla.org/en-US/docs/Web/API/RequestInit) interface.",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [],
  "file": {
    "content": "import { useState, useEffect, useCallback, useRef } from \"react\";\r\n\r\n\r\nexport interface UseFetchOptions extends RequestInit {\r\n  \r\n  immediate?: boolean;\r\n  \r\n  onSuccess?: (data: any) => void;\r\n  \r\n  onError?: (error: Error) => void;\r\n}\r\n\r\n\r\nexport interface UseFetchState<T> {\r\n  \r\n  data: T | null;\r\n  \r\n  loading: boolean;\r\n  \r\n  error: Error | null;\r\n}\r\n\r\n\r\nexport interface UseFetchReturn<T> extends UseFetchState<T> {\r\n  \r\n  execute: (url?: string, options?: RequestInit) => Promise<T | null>;\r\n  \r\n  abort: () => void;\r\n  \r\n  reset: () => void;\r\n}\r\n\r\n\r\nexport function useFetch<T = any>(\r\n  url?: string,\r\n  options: UseFetchOptions = {},\r\n): UseFetchReturn<T> {\r\n  const [state, setState] = useState<UseFetchState<T>>({\r\n    data: null,\r\n    loading: false,\r\n    error: null,\r\n  });\r\n\r\n  const abortControllerRef = useRef<AbortController | null>(null);\r\n  const optionsRef = useRef(options);\r\n\r\n  \r\n  useEffect(() => {\r\n    optionsRef.current = options;\r\n  }, [options]);\r\n\r\n  const execute = useCallback(\r\n    async (\r\n      executeUrl?: string,\r\n      executeOptions?: RequestInit,\r\n    ): Promise<T | null> => {\r\n      const targetUrl = executeUrl || url;\r\n\r\n      if (!targetUrl) {\r\n        const error = new Error(\"No URL provided\");\r\n        setState((prev) => ({ ...prev, error, loading: false }));\r\n        optionsRef.current.onError?.(error);\r\n        throw error;\r\n      }\r\n\r\n      \r\n      if (abortControllerRef.current) {\r\n        abortControllerRef.current.abort();\r\n      }\r\n\r\n      \r\n      abortControllerRef.current = new AbortController();\r\n\r\n      setState((prev) => ({ ...prev, loading: true, error: null }));\r\n\r\n      try {\r\n        const { immediate, onSuccess, onError, ...fetchOptions } =\r\n          optionsRef.current;\r\n\r\n        const response = await fetch(targetUrl, {\r\n          ...fetchOptions,\r\n          ...executeOptions,\r\n          signal: abortControllerRef.current.signal,\r\n        });\r\n\r\n        if (!response.ok) {\r\n          throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n\r\n        \r\n        let data: T;\r\n        const contentType = response.headers.get(\"content-type\");\r\n\r\n        if (contentType && contentType.includes(\"application/json\")) {\r\n          data = await response.json();\r\n        } else {\r\n          data = (await response.text()) as T;\r\n        }\r\n\r\n        setState({ data, loading: false, error: null });\r\n        onSuccess?.(data);\r\n        return data;\r\n      } catch (error) {\r\n        const fetchError = error as Error;\r\n\r\n        \r\n        if (fetchError.name !== \"AbortError\") {\r\n          setState((prev) => ({ ...prev, loading: false, error: fetchError }));\r\n          optionsRef.current.onError?.(fetchError);\r\n        }\r\n\r\n        throw fetchError;\r\n      }\r\n    },\r\n    [url],\r\n  );\r\n\r\n  const abort = useCallback(() => {\r\n    if (abortControllerRef.current) {\r\n      abortControllerRef.current.abort();\r\n      abortControllerRef.current = null;\r\n    }\r\n  }, []);\r\n\r\n  const reset = useCallback(() => {\r\n    abort();\r\n    setState({ data: null, loading: false, error: null });\r\n  }, [abort]);\r\n\r\n  \r\n  useEffect(() => {\r\n    if (options.immediate && url) {\r\n      execute();\r\n    }\r\n  }, [url, options.immediate, execute]);\r\n\r\n  \r\n  useEffect(() => {\r\n    return () => {\r\n      abort();\r\n    };\r\n  }, [abort]);\r\n\r\n  return {\r\n    ...state,\r\n    execute,\r\n    abort,\r\n    reset,\r\n  };\r\n}\r\n\r\n\r\nexport function useGet<T = any>(url?: string, options: UseFetchOptions = {}) {\r\n  return useFetch<T>(url, { ...options, method: \"GET\" });\r\n}\r\n\r\nexport function usePost<T = any>(url?: string, options: UseFetchOptions = {}) {\r\n  return useFetch<T>(url, { ...options, method: \"POST\" });\r\n}\r\n\r\nexport function usePut<T = any>(url?: string, options: UseFetchOptions = {}) {\r\n  return useFetch<T>(url, { ...options, method: \"PUT\" });\r\n}\r\n\r\nexport function useDelete<T = any>(\r\n  url?: string,\r\n  options: UseFetchOptions = {},\r\n) {\r\n  return useFetch<T>(url, { ...options, method: \"DELETE\" });\r\n}",
    "js": "import { useState, useEffect, useCallback, useRef } from \"react\";\nexport function useFetch(url, options = {}) {\n    const [state, setState] = useState({\n        data: null,\n        loading: false,\n        error: null,\n    });\n    const abortControllerRef = useRef(null);\n    const optionsRef = useRef(options);\n    useEffect(() => {\n        optionsRef.current = options;\n    }, [options]);\n    const execute = useCallback(async (executeUrl, executeOptions) => {\n        const targetUrl = executeUrl || url;\n        if (!targetUrl) {\n            const error = new Error(\"No URL provided\");\n            setState((prev) => ({ ...prev, error, loading: false }));\n            optionsRef.current.onError?.(error);\n            throw error;\n        }\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n        }\n        abortControllerRef.current = new AbortController();\n        setState((prev) => ({ ...prev, loading: true, error: null }));\n        try {\n            const { immediate, onSuccess, onError, ...fetchOptions } = optionsRef.current;\n            const response = await fetch(targetUrl, {\n                ...fetchOptions,\n                ...executeOptions,\n                signal: abortControllerRef.current.signal,\n            });\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n            let data;\n            const contentType = response.headers.get(\"content-type\");\n            if (contentType && contentType.includes(\"application/json\")) {\n                data = await response.json();\n            }\n            else {\n                data = (await response.text());\n            }\n            setState({ data, loading: false, error: null });\n            onSuccess?.(data);\n            return data;\n        }\n        catch (error) {\n            const fetchError = error;\n            if (fetchError.name !== \"AbortError\") {\n                setState((prev) => ({ ...prev, loading: false, error: fetchError }));\n                optionsRef.current.onError?.(fetchError);\n            }\n            throw fetchError;\n        }\n    }, [url]);\n    const abort = useCallback(() => {\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const reset = useCallback(() => {\n        abort();\n        setState({ data: null, loading: false, error: null });\n    }, [abort]);\n    useEffect(() => {\n        if (options.immediate && url) {\n            execute();\n        }\n    }, [url, options.immediate, execute]);\n    useEffect(() => {\n        return () => {\n            abort();\n        };\n    }, [abort]);\n    return {\n        ...state,\n        execute,\n        abort,\n        reset,\n    };\n}\nexport function useGet(url, options = {}) {\n    return useFetch(url, { ...options, method: \"GET\" });\n}\nexport function usePost(url, options = {}) {\n    return useFetch(url, { ...options, method: \"POST\" });\n}\nexport function usePut(url, options = {}) {\n    return useFetch(url, { ...options, method: \"PUT\" });\n}\nexport function useDelete(url, options = {}) {\n    return useFetch(url, { ...options, method: \"DELETE\" });\n}"
  }
}