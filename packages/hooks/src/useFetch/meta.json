{
  "$schema": "https://sse-hooks.vercel.app/api/registry/schema/hook.json",
  "name": "use-fetch",
  "type": "registry:hook",
  "title": "useFetch",
  "description": "Options for customizing the behavior of the useFetch hook. Extends the standard [`RequestInit`](https://developer.mozilla.org/en-US/docs/Web/API/RequestInit) interface.",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [],
  "file": {
    "content": "import { useState, useEffect, useCallback, useRef } from \"react\";\n\nexport interface UseFetchOptions extends RequestInit {\n  immediate?: boolean;\n\n  onSuccess?: (data: any) => void;\n\n  onError?: (error: Error) => void;\n}\n\nexport interface UseFetchState<T> {\n  data: T | null;\n\n  loading: boolean;\n\n  error: Error | null;\n}\n\nexport interface UseFetchReturn<T> extends UseFetchState<T> {\n  execute: (url?: string, options?: RequestInit) => Promise<T | null>;\n\n  abort: () => void;\n\n  reset: () => void;\n}\n\nexport function useFetch<T = any>(\n  url?: string,\n  options: UseFetchOptions = {},\n): UseFetchReturn<T> {\n  const [state, setState] = useState<UseFetchState<T>>({\n    data: null,\n    loading: false,\n    error: null,\n  });\n\n  const abortControllerRef = useRef<AbortController | null>(null);\n  const optionsRef = useRef(options);\n\n  useEffect(() => {\n    optionsRef.current = options;\n  }, [options]);\n\n  const execute = useCallback(\n    async (\n      executeUrl?: string,\n      executeOptions?: RequestInit,\n    ): Promise<T | null> => {\n      const targetUrl = executeUrl || url;\n\n      if (!targetUrl) {\n        const error = new Error(\"No URL provided\");\n        setState((prev) => ({ ...prev, error, loading: false }));\n        optionsRef.current.onError?.(error);\n        throw error;\n      }\n\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n\n      abortControllerRef.current = new AbortController();\n\n      setState((prev) => ({ ...prev, loading: true, error: null }));\n\n      try {\n        const { immediate, onSuccess, onError, ...fetchOptions } =\n          optionsRef.current;\n\n        const response = await fetch(targetUrl, {\n          ...fetchOptions,\n          ...executeOptions,\n          signal: abortControllerRef.current.signal,\n        });\n\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        let data: T;\n        const contentType = response.headers.get(\"content-type\");\n\n        if (contentType && contentType.includes(\"application/json\")) {\n          data = await response.json();\n        } else {\n          data = (await response.text()) as T;\n        }\n\n        setState({ data, loading: false, error: null });\n        onSuccess?.(data);\n        return data;\n      } catch (error) {\n        const fetchError = error as Error;\n\n        if (fetchError.name !== \"AbortError\") {\n          setState((prev) => ({ ...prev, loading: false, error: fetchError }));\n          optionsRef.current.onError?.(fetchError);\n        }\n\n        throw fetchError;\n      }\n    },\n    [url],\n  );\n\n  const abort = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n  }, []);\n\n  const reset = useCallback(() => {\n    abort();\n    setState({ data: null, loading: false, error: null });\n  }, [abort]);\n\n  useEffect(() => {\n    if (options.immediate && url) {\n      execute();\n    }\n  }, [url, options.immediate, execute]);\n\n  useEffect(() => {\n    return () => {\n      abort();\n    };\n  }, [abort]);\n\n  return {\n    ...state,\n    execute,\n    abort,\n    reset,\n  };\n}\n\nexport function useGet<T = any>(url?: string, options: UseFetchOptions = {}) {\n  return useFetch<T>(url, { ...options, method: \"GET\" });\n}\n\nexport function usePost<T = any>(url?: string, options: UseFetchOptions = {}) {\n  return useFetch<T>(url, { ...options, method: \"POST\" });\n}\n\nexport function usePut<T = any>(url?: string, options: UseFetchOptions = {}) {\n  return useFetch<T>(url, { ...options, method: \"PUT\" });\n}\n\nexport function useDelete<T = any>(\n  url?: string,\n  options: UseFetchOptions = {},\n) {\n  return useFetch<T>(url, { ...options, method: \"DELETE\" });\n}\n",
    "js": "import { useState, useEffect, useCallback, useRef } from \"react\";\nexport function useFetch(url, options = {}) {\n    const [state, setState] = useState({\n        data: null,\n        loading: false,\n        error: null,\n    });\n    const abortControllerRef = useRef(null);\n    const optionsRef = useRef(options);\n    useEffect(() => {\n        optionsRef.current = options;\n    }, [options]);\n    const execute = useCallback(async (executeUrl, executeOptions) => {\n        const targetUrl = executeUrl || url;\n        if (!targetUrl) {\n            const error = new Error(\"No URL provided\");\n            setState((prev) => ({ ...prev, error, loading: false }));\n            optionsRef.current.onError?.(error);\n            throw error;\n        }\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n        }\n        abortControllerRef.current = new AbortController();\n        setState((prev) => ({ ...prev, loading: true, error: null }));\n        try {\n            const { immediate, onSuccess, onError, ...fetchOptions } = optionsRef.current;\n            const response = await fetch(targetUrl, {\n                ...fetchOptions,\n                ...executeOptions,\n                signal: abortControllerRef.current.signal,\n            });\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n            let data;\n            const contentType = response.headers.get(\"content-type\");\n            if (contentType && contentType.includes(\"application/json\")) {\n                data = await response.json();\n            }\n            else {\n                data = (await response.text());\n            }\n            setState({ data, loading: false, error: null });\n            onSuccess?.(data);\n            return data;\n        }\n        catch (error) {\n            const fetchError = error;\n            if (fetchError.name !== \"AbortError\") {\n                setState((prev) => ({ ...prev, loading: false, error: fetchError }));\n                optionsRef.current.onError?.(fetchError);\n            }\n            throw fetchError;\n        }\n    }, [url]);\n    const abort = useCallback(() => {\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const reset = useCallback(() => {\n        abort();\n        setState({ data: null, loading: false, error: null });\n    }, [abort]);\n    useEffect(() => {\n        if (options.immediate && url) {\n            execute();\n        }\n    }, [url, options.immediate, execute]);\n    useEffect(() => {\n        return () => {\n            abort();\n        };\n    }, [abort]);\n    return {\n        ...state,\n        execute,\n        abort,\n        reset,\n    };\n}\nexport function useGet(url, options = {}) {\n    return useFetch(url, { ...options, method: \"GET\" });\n}\nexport function usePost(url, options = {}) {\n    return useFetch(url, { ...options, method: \"POST\" });\n}\nexport function usePut(url, options = {}) {\n    return useFetch(url, { ...options, method: \"PUT\" });\n}\nexport function useDelete(url, options = {}) {\n    return useFetch(url, { ...options, method: \"DELETE\" });\n}"
  }
}