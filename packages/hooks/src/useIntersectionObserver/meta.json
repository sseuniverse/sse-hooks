{
  "$schema": "https://sse-hooks.vercel.app/api/registry/schema/hook.json",
  "name": "use-intersection-observer",
  "type": "registry:hook",
  "title": "useIntersectionObserver",
  "description": "The hook internal state.",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [],
  "file": {
    "content": "import { useEffect, useRef, useState } from \"react\";\n\ntype State = {\n  isIntersecting: boolean;\n\n  entry?: IntersectionObserverEntry;\n};\n\ntype UseIntersectionObserverOptions = {\n  root?: Element | Document | null;\n\n  rootMargin?: string;\n\n  threshold?: number | number[];\n\n  freezeOnceVisible?: boolean;\n\n  onChange?: (\n    isIntersecting: boolean,\n    entry: IntersectionObserverEntry,\n  ) => void;\n\n  initialIsIntersecting?: boolean;\n};\n\ntype IntersectionReturn = [\n  (node?: Element | null) => void,\n  boolean,\n  IntersectionObserverEntry | undefined,\n] & {\n  ref: (node?: Element | null) => void;\n  isIntersecting: boolean;\n  entry?: IntersectionObserverEntry;\n};\n\nexport function useIntersectionObserver({\n  threshold = 0,\n  root = null,\n  rootMargin = \"0%\",\n  freezeOnceVisible = false,\n  initialIsIntersecting = false,\n  onChange,\n}: UseIntersectionObserverOptions = {}): IntersectionReturn {\n  const [ref, setRef] = useState<Element | null>(null);\n\n  const [state, setState] = useState<State>(() => ({\n    isIntersecting: initialIsIntersecting,\n    entry: undefined,\n  }));\n\n  const callbackRef = useRef<UseIntersectionObserverOptions[\"onChange\"]>();\n\n  callbackRef.current = onChange;\n\n  const frozen = state.entry?.isIntersecting && freezeOnceVisible;\n\n  useEffect(() => {\n    if (!ref) return;\n\n    if (!(\"IntersectionObserver\" in window)) return;\n\n    if (frozen) return;\n\n    let unobserve: (() => void) | undefined;\n\n    const observer = new IntersectionObserver(\n      (entries: IntersectionObserverEntry[]): void => {\n        const thresholds = Array.isArray(observer.thresholds)\n          ? observer.thresholds\n          : [observer.thresholds];\n\n        entries.forEach((entry) => {\n          const isIntersecting =\n            entry.isIntersecting &&\n            thresholds.some(\n              (threshold) => entry.intersectionRatio >= threshold,\n            );\n\n          setState({ isIntersecting, entry });\n\n          if (callbackRef.current) {\n            callbackRef.current(isIntersecting, entry);\n          }\n\n          if (isIntersecting && freezeOnceVisible && unobserve) {\n            unobserve();\n            unobserve = undefined;\n          }\n        });\n      },\n      { threshold, root, rootMargin },\n    );\n\n    observer.observe(ref);\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [\n    ref,\n\n    JSON.stringify(threshold),\n    root,\n    rootMargin,\n    frozen,\n    freezeOnceVisible,\n  ]);\n\n  const prevRef = useRef<Element | null>(null);\n\n  useEffect(() => {\n    if (\n      !ref &&\n      state.entry?.target &&\n      !freezeOnceVisible &&\n      !frozen &&\n      prevRef.current !== state.entry.target\n    ) {\n      prevRef.current = state.entry.target;\n      setState({ isIntersecting: initialIsIntersecting, entry: undefined });\n    }\n  }, [ref, state.entry, freezeOnceVisible, frozen, initialIsIntersecting]);\n\n  const result = [\n    setRef,\n    !!state.isIntersecting,\n    state.entry,\n  ] as IntersectionReturn;\n\n  result.ref = result[0];\n  result.isIntersecting = result[1];\n  result.entry = result[2];\n\n  return result;\n}\n",
    "js": "import { useEffect, useRef, useState } from \"react\";\nexport function useIntersectionObserver({ threshold = 0, root = null, rootMargin = \"0%\", freezeOnceVisible = false, initialIsIntersecting = false, onChange, } = {}) {\n    const [ref, setRef] = useState(null);\n    const [state, setState] = useState(() => ({\n        isIntersecting: initialIsIntersecting,\n        entry: undefined,\n    }));\n    const callbackRef = useRef();\n    callbackRef.current = onChange;\n    const frozen = state.entry?.isIntersecting && freezeOnceVisible;\n    useEffect(() => {\n        if (!ref)\n            return;\n        if (!(\"IntersectionObserver\" in window))\n            return;\n        if (frozen)\n            return;\n        let unobserve;\n        const observer = new IntersectionObserver((entries) => {\n            const thresholds = Array.isArray(observer.thresholds)\n                ? observer.thresholds\n                : [observer.thresholds];\n            entries.forEach((entry) => {\n                const isIntersecting = entry.isIntersecting &&\n                    thresholds.some((threshold) => entry.intersectionRatio >= threshold);\n                setState({ isIntersecting, entry });\n                if (callbackRef.current) {\n                    callbackRef.current(isIntersecting, entry);\n                }\n                if (isIntersecting && freezeOnceVisible && unobserve) {\n                    unobserve();\n                    unobserve = undefined;\n                }\n            });\n        }, { threshold, root, rootMargin });\n        observer.observe(ref);\n        return () => {\n            observer.disconnect();\n        };\n    }, [\n        ref,\n        JSON.stringify(threshold),\n        root,\n        rootMargin,\n        frozen,\n        freezeOnceVisible,\n    ]);\n    const prevRef = useRef(null);\n    useEffect(() => {\n        if (!ref &&\n            state.entry?.target &&\n            !freezeOnceVisible &&\n            !frozen &&\n            prevRef.current !== state.entry.target) {\n            prevRef.current = state.entry.target;\n            setState({ isIntersecting: initialIsIntersecting, entry: undefined });\n        }\n    }, [ref, state.entry, freezeOnceVisible, frozen, initialIsIntersecting]);\n    const result = [\n        setRef,\n        !!state.isIntersecting,\n        state.entry,\n    ];\n    result.ref = result[0];\n    result.isIntersecting = result[1];\n    result.entry = result[2];\n    return result;\n}"
  }
}