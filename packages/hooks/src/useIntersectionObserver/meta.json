{
  "$schema": "https://raw.githubusercontent.com/sseuniverse/sse-hooks/refs/heads/main/schema/meta.json",
  "name": "use-intersection-observer",
  "type": "registry:hook",
  "title": "useIntersectionObserver",
  "description": "The hook internal state.",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [],
  "file": {
    "content": "import { useEffect, useRef, useState } from \"react\";\r\n\r\n\r\ntype State = {\r\n  \r\n  isIntersecting: boolean;\r\n  \r\n  entry?: IntersectionObserverEntry;\r\n};\r\n\r\n\r\ntype UseIntersectionObserverOptions = {\r\n  \r\n  root?: Element | Document | null;\r\n  \r\n  rootMargin?: string;\r\n  \r\n  threshold?: number | number[];\r\n  \r\n  freezeOnceVisible?: boolean;\r\n  \r\n  onChange?: (\r\n    isIntersecting: boolean,\r\n    entry: IntersectionObserverEntry,\r\n  ) => void;\r\n  \r\n  initialIsIntersecting?: boolean;\r\n};\r\n\r\n\r\ntype IntersectionReturn = [\r\n  (node?: Element | null) => void,\r\n  boolean,\r\n  IntersectionObserverEntry | undefined,\r\n] & {\r\n  ref: (node?: Element | null) => void;\r\n  isIntersecting: boolean;\r\n  entry?: IntersectionObserverEntry;\r\n};\r\n\r\n\r\nexport function useIntersectionObserver({\r\n  threshold = 0,\r\n  root = null,\r\n  rootMargin = \"0%\",\r\n  freezeOnceVisible = false,\r\n  initialIsIntersecting = false,\r\n  onChange,\r\n}: UseIntersectionObserverOptions = {}): IntersectionReturn {\r\n  const [ref, setRef] = useState<Element | null>(null);\r\n\r\n  const [state, setState] = useState<State>(() => ({\r\n    isIntersecting: initialIsIntersecting,\r\n    entry: undefined,\r\n  }));\r\n\r\n  \r\n  const callbackRef = useRef<UseIntersectionObserverOptions[\"onChange\"]>();\r\n\r\n  callbackRef.current = onChange;\r\n\r\n  const frozen = state.entry?.isIntersecting && freezeOnceVisible;\r\n\r\n  useEffect(() => {\r\n    \r\n    if (!ref) return;\r\n\r\n    \r\n    if (!(\"IntersectionObserver\" in window)) return;\r\n\r\n    \r\n    if (frozen) return;\r\n\r\n    let unobserve: (() => void) | undefined;\r\n\r\n    const observer = new IntersectionObserver(\r\n      (entries: IntersectionObserverEntry[]): void => {\r\n        const thresholds = Array.isArray(observer.thresholds)\r\n          ? observer.thresholds\r\n          : [observer.thresholds];\r\n\r\n        entries.forEach((entry) => {\r\n          const isIntersecting =\r\n            entry.isIntersecting &&\r\n            thresholds.some(\r\n              (threshold) => entry.intersectionRatio >= threshold,\r\n            );\r\n\r\n          setState({ isIntersecting, entry });\r\n\r\n          if (callbackRef.current) {\r\n            callbackRef.current(isIntersecting, entry);\r\n          }\r\n\r\n          if (isIntersecting && freezeOnceVisible && unobserve) {\r\n            unobserve();\r\n            unobserve = undefined;\r\n          }\r\n        });\r\n      },\r\n      { threshold, root, rootMargin },\r\n    );\r\n\r\n    observer.observe(ref);\r\n\r\n    return () => {\r\n      observer.disconnect();\r\n    };\r\n\r\n    \r\n  }, [\r\n    ref,\r\n    \r\n    JSON.stringify(threshold),\r\n    root,\r\n    rootMargin,\r\n    frozen,\r\n    freezeOnceVisible,\r\n  ]);\r\n\r\n  \r\n  const prevRef = useRef<Element | null>(null);\r\n\r\n  useEffect(() => {\r\n    if (\r\n      !ref &&\r\n      state.entry?.target &&\r\n      !freezeOnceVisible &&\r\n      !frozen &&\r\n      prevRef.current !== state.entry.target\r\n    ) {\r\n      prevRef.current = state.entry.target;\r\n      setState({ isIntersecting: initialIsIntersecting, entry: undefined });\r\n    }\r\n  }, [ref, state.entry, freezeOnceVisible, frozen, initialIsIntersecting]);\r\n\r\n  const result = [\r\n    setRef,\r\n    !!state.isIntersecting,\r\n    state.entry,\r\n  ] as IntersectionReturn;\r\n\r\n  \r\n  result.ref = result[0];\r\n  result.isIntersecting = result[1];\r\n  result.entry = result[2];\r\n\r\n  return result;\r\n}",
    "js": "import { useEffect, useRef, useState } from \"react\";\nexport function useIntersectionObserver({ threshold = 0, root = null, rootMargin = \"0%\", freezeOnceVisible = false, initialIsIntersecting = false, onChange, } = {}) {\n    const [ref, setRef] = useState(null);\n    const [state, setState] = useState(() => ({\n        isIntersecting: initialIsIntersecting,\n        entry: undefined,\n    }));\n    const callbackRef = useRef();\n    callbackRef.current = onChange;\n    const frozen = state.entry?.isIntersecting && freezeOnceVisible;\n    useEffect(() => {\n        if (!ref)\n            return;\n        if (!(\"IntersectionObserver\" in window))\n            return;\n        if (frozen)\n            return;\n        let unobserve;\n        const observer = new IntersectionObserver((entries) => {\n            const thresholds = Array.isArray(observer.thresholds)\n                ? observer.thresholds\n                : [observer.thresholds];\n            entries.forEach((entry) => {\n                const isIntersecting = entry.isIntersecting &&\n                    thresholds.some((threshold) => entry.intersectionRatio >= threshold);\n                setState({ isIntersecting, entry });\n                if (callbackRef.current) {\n                    callbackRef.current(isIntersecting, entry);\n                }\n                if (isIntersecting && freezeOnceVisible && unobserve) {\n                    unobserve();\n                    unobserve = undefined;\n                }\n            });\n        }, { threshold, root, rootMargin });\n        observer.observe(ref);\n        return () => {\n            observer.disconnect();\n        };\n    }, [\n        ref,\n        JSON.stringify(threshold),\n        root,\n        rootMargin,\n        frozen,\n        freezeOnceVisible,\n    ]);\n    const prevRef = useRef(null);\n    useEffect(() => {\n        if (!ref &&\n            state.entry?.target &&\n            !freezeOnceVisible &&\n            !frozen &&\n            prevRef.current !== state.entry.target) {\n            prevRef.current = state.entry.target;\n            setState({ isIntersecting: initialIsIntersecting, entry: undefined });\n        }\n    }, [ref, state.entry, freezeOnceVisible, frozen, initialIsIntersecting]);\n    const result = [\n        setRef,\n        !!state.isIntersecting,\n        state.entry,\n    ];\n    result.ref = result[0];\n    result.isIntersecting = result[1];\n    result.entry = result[2];\n    return result;\n}"
  }
}