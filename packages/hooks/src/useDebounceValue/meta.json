{
  "$schema": "https://sse-hooks.vercel.app/api/registry/schema/hook.json",
  "name": "use-debounce-value",
  "type": "registry:hook",
  "title": "useDebounceValue",
  "description": "Hook options.",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [
    "use-debounce-callback"
  ],
  "file": {
    "content": "import { useRef, useState } from \"react\";\nimport type { DebouncedState } from \"./use-debounce-callback\";\nimport { useDebounceCallback } from \"./use-debounce-callback\";\n\ntype UseDebounceValueOptions<T> = {\n  leading?: boolean;\n\n  trailing?: boolean;\n\n  maxWait?: number;\n\n  equalityFn?: (left: T, right: T) => boolean;\n};\n\nexport function useDebounceValue<T>(\n  initialValue: T | (() => T),\n  delay: number,\n  options?: UseDebounceValueOptions<T>,\n): [T, DebouncedState<(value: T) => void>] {\n  const eq = options?.equalityFn ?? ((left: T, right: T) => left === right);\n  const unwrappedInitialValue =\n    initialValue instanceof Function ? initialValue() : initialValue;\n  const [debouncedValue, setDebouncedValue] = useState<T>(\n    unwrappedInitialValue,\n  );\n  const previousValueRef = useRef<T | undefined>(unwrappedInitialValue);\n\n  const updateDebouncedValue = useDebounceCallback(\n    setDebouncedValue,\n    delay,\n    options,\n  );\n\n  if (!eq(previousValueRef.current as T, unwrappedInitialValue)) {\n    updateDebouncedValue(unwrappedInitialValue);\n    previousValueRef.current = unwrappedInitialValue;\n  }\n\n  return [debouncedValue, updateDebouncedValue];\n}\n",
    "js": "import { useRef, useState } from \"react\";\nimport { useDebounceCallback } from \"./use-debounce-callback\";\nexport function useDebounceValue(initialValue, delay, options) {\n    const eq = options?.equalityFn ?? ((left, right) => left === right);\n    const unwrappedInitialValue = initialValue instanceof Function ? initialValue() : initialValue;\n    const [debouncedValue, setDebouncedValue] = useState(unwrappedInitialValue);\n    const previousValueRef = useRef(unwrappedInitialValue);\n    const updateDebouncedValue = useDebounceCallback(setDebouncedValue, delay, options);\n    if (!eq(previousValueRef.current, unwrappedInitialValue)) {\n        updateDebouncedValue(unwrappedInitialValue);\n        previousValueRef.current = unwrappedInitialValue;\n    }\n    return [debouncedValue, updateDebouncedValue];\n}"
  }
}