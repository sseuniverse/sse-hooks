{
  "$schema": "https://sse-hooks.vercel.app/api/registry/schema/hook.json",
  "name": "use-search-with-suggestions",
  "type": "registry:hook",
  "title": "useSearchWithSuggestions",
  "description": "The string trigger (e.g., \":user\"). Auto-prefixed with \":\" if missing.",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [],
  "file": {
    "content": "import { useMemo, useState, useCallback } from \"react\";\nimport React from \"react\";\n\nexport type BaseCommand = {\n  trigger: string;\n};\n\nexport type ScopedCommand<T> = BaseCommand & {\n  scope: keyof T;\n  filter?: never;\n};\n\nexport type FilterCommand<T> = BaseCommand & {\n  filter: (item: T) => boolean;\n  scope?: never;\n};\n\nexport type CommandConfig<T> = ScopedCommand<T> | FilterCommand<T>;\n\nexport type BaseSearchConfig<T> = {\n  commands?: CommandConfig<T>[];\n\n  fuzzy?: boolean;\n\n  maxResults?: number;\n};\n\nexport interface UseSearchSuggestionsResult<T> {\n  query: string;\n  setQuery: React.Dispatch<React.SetStateAction<string>>;\n\n  filteredData: T[];\n\n  ghostText: string;\n\n  isSuggestionAvailable: boolean;\n\n  inputProps: {\n    value: string;\n    onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;\n    onKeyDown: (e: React.KeyboardEvent<HTMLInputElement>) => void;\n    placeholder?: string;\n  };\n\n  activeCommand: string | null;\n}\n\nexport function filterList<T, K extends keyof T>(\n  list: T[],\n  keys: readonly K[],\n  term: string,\n  isFuzzy: boolean,\n): T[] {\n  if (!term) return list;\n\n  return list.filter((item) =>\n    keys.some((key) => {\n      const val = item[key];\n      const strVal = String(val).toLowerCase();\n\n      if (Array.isArray(val)) {\n        return (val as string[]).some((v) =>\n          isFuzzy\n            ? v.toLowerCase().includes(term)\n            : v.toLowerCase().startsWith(term),\n        );\n      }\n\n      return isFuzzy ? strVal.includes(term) : strVal.startsWith(term);\n    }),\n  );\n}\n\nexport function useSearchWithSuggestions<\n  T extends Record<string, any>,\n  K extends keyof T = keyof T,\n>(\n  data: T[],\n  searchKeys: readonly K[],\n  config?: BaseSearchConfig<T>,\n): UseSearchSuggestionsResult<T>;\n\nexport function useSearchWithSuggestions<\n  T extends Record<string, any>,\n  K extends keyof T = keyof T,\n>(\n  data: T[],\n  searchKeys: readonly K[],\n  config: BaseSearchConfig<T> = {},\n): UseSearchSuggestionsResult<T> {\n  const { commands = [], fuzzy = false, maxResults } = config;\n  const [query, setQuery] = useState(\"\");\n\n  const normalizedCommands = useMemo(() => {\n    return commands.map((cmd) => ({\n      ...cmd,\n      trigger: cmd.trigger.startsWith(\":\") ? cmd.trigger : `:${cmd.trigger}`,\n    }));\n  }, [commands]);\n\n  const activeCommandObj = useMemo(() => {\n    if (!query) return null;\n    const lowerQuery = query.toLowerCase();\n\n    return normalizedCommands.find(\n      (cmd) =>\n        lowerQuery.startsWith(cmd.trigger + \" \") || lowerQuery === cmd.trigger,\n    );\n  }, [query, normalizedCommands]);\n\n  const suggestionDetails = useMemo(() => {\n    if (!query) return null;\n    const lowerQuery = query.toLowerCase();\n\n    if (lowerQuery.startsWith(\":\") && !lowerQuery.includes(\" \")) {\n      const matchedCommand = normalizedCommands.find(\n        (cmd) =>\n          cmd.trigger.startsWith(lowerQuery) && lowerQuery !== cmd.trigger,\n      );\n      if (matchedCommand) {\n        return { text: matchedCommand.trigger, isCommand: true };\n      }\n    }\n\n    let searchPart = lowerQuery;\n    let keysToSearch = searchKeys;\n\n    if (activeCommandObj) {\n      if (lowerQuery.length <= activeCommandObj.trigger.length) return null;\n      searchPart = lowerQuery.replace(activeCommandObj.trigger, \"\").trim();\n\n      if (activeCommandObj.scope) {\n        keysToSearch = [activeCommandObj.scope as K];\n      }\n    }\n\n    if (!searchPart) return null;\n\n    const match = data.find((item) => {\n      return keysToSearch.some((key) => {\n        const val = item[key];\n        const strVal = String(val).toLowerCase();\n\n        if (Array.isArray(val)) {\n          return (val as string[]).some((v) =>\n            v.toLowerCase().startsWith(searchPart),\n          );\n        }\n        return strVal.startsWith(searchPart);\n      });\n    });\n\n    if (match) {\n      let matchedText = \"\";\n      for (const key of keysToSearch) {\n        const val = match[key];\n        if (Array.isArray(val)) {\n          const subMatch = (val as string[]).find((v) =>\n            v.toLowerCase().startsWith(searchPart),\n          );\n          if (subMatch) {\n            matchedText = subMatch;\n            break;\n          }\n        } else if (String(val).toLowerCase().startsWith(searchPart)) {\n          matchedText = String(val);\n          break;\n        }\n      }\n\n      if (matchedText) {\n        const prefix = activeCommandObj ? activeCommandObj.trigger + \" \" : \"\";\n        return { text: prefix + matchedText, isCommand: false };\n      }\n    }\n\n    return null;\n  }, [query, data, searchKeys, normalizedCommands, activeCommandObj]);\n\n  const ghostText = useMemo(() => {\n    if (!suggestionDetails || !query) return \"\";\n    const fullSuggestion = suggestionDetails.text;\n    if (fullSuggestion.toLowerCase().startsWith(query.toLowerCase())) {\n      return query + fullSuggestion.slice(query.length);\n    }\n    return \"\";\n  }, [query, suggestionDetails]);\n\n  const filteredData = useMemo(() => {\n    let results = data;\n    const lowerQuery = query.toLowerCase();\n\n    if (\n      lowerQuery.startsWith(\":\") &&\n      !lowerQuery.includes(\" \") &&\n      !activeCommandObj\n    ) {\n      return [];\n    }\n\n    if (activeCommandObj) {\n      if (activeCommandObj.filter) {\n        results = results.filter(activeCommandObj.filter);\n      }\n\n      const searchPart = lowerQuery\n        .replace(activeCommandObj.trigger, \"\")\n        .trim();\n\n      if (searchPart) {\n        const keysToSearch = activeCommandObj.scope\n          ? [activeCommandObj.scope as K]\n          : searchKeys;\n        results = filterList(results, keysToSearch, searchPart, fuzzy);\n      }\n    } else {\n      results = filterList(results, searchKeys, lowerQuery, fuzzy);\n    }\n\n    return maxResults ? results.slice(0, maxResults) : results;\n  }, [query, data, searchKeys, activeCommandObj, fuzzy, maxResults]);\n\n  const handleChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {\n    setQuery(e.target.value);\n  }, []);\n\n  const handleKeyDown = useCallback(\n    (e: React.KeyboardEvent<HTMLInputElement>) => {\n      if (e.key === \"Tab\" && suggestionDetails) {\n        e.preventDefault();\n        const suffix = suggestionDetails.isCommand ? \" \" : \"\";\n        setQuery(suggestionDetails.text + suffix);\n      }\n    },\n    [suggestionDetails],\n  );\n\n  return {\n    query,\n    setQuery,\n    filteredData,\n    ghostText,\n    isSuggestionAvailable: !!suggestionDetails,\n    activeCommand: activeCommandObj?.trigger ?? null,\n    inputProps: {\n      value: query,\n      onChange: handleChange,\n      onKeyDown: handleKeyDown,\n      placeholder: activeCommandObj\n        ? `Search in ${activeCommandObj.trigger}...`\n        : `Search or type ':' for commands...`,\n    },\n  };\n}\n",
    "js": "import { useMemo, useState, useCallback } from \"react\";\nexport function filterList(list, keys, term, isFuzzy) {\n    if (!term)\n        return list;\n    return list.filter((item) => keys.some((key) => {\n        const val = item[key];\n        const strVal = String(val).toLowerCase();\n        if (Array.isArray(val)) {\n            return val.some((v) => isFuzzy\n                ? v.toLowerCase().includes(term)\n                : v.toLowerCase().startsWith(term));\n        }\n        return isFuzzy ? strVal.includes(term) : strVal.startsWith(term);\n    }));\n}\nexport function useSearchWithSuggestions(data, searchKeys, config = {}) {\n    const { commands = [], fuzzy = false, maxResults } = config;\n    const [query, setQuery] = useState(\"\");\n    const normalizedCommands = useMemo(() => {\n        return commands.map((cmd) => ({\n            ...cmd,\n            trigger: cmd.trigger.startsWith(\":\") ? cmd.trigger : `:${cmd.trigger}`,\n        }));\n    }, [commands]);\n    const activeCommandObj = useMemo(() => {\n        if (!query)\n            return null;\n        const lowerQuery = query.toLowerCase();\n        return normalizedCommands.find((cmd) => lowerQuery.startsWith(cmd.trigger + \" \") || lowerQuery === cmd.trigger);\n    }, [query, normalizedCommands]);\n    const suggestionDetails = useMemo(() => {\n        if (!query)\n            return null;\n        const lowerQuery = query.toLowerCase();\n        if (lowerQuery.startsWith(\":\") && !lowerQuery.includes(\" \")) {\n            const matchedCommand = normalizedCommands.find((cmd) => cmd.trigger.startsWith(lowerQuery) && lowerQuery !== cmd.trigger);\n            if (matchedCommand) {\n                return { text: matchedCommand.trigger, isCommand: true };\n            }\n        }\n        let searchPart = lowerQuery;\n        let keysToSearch = searchKeys;\n        if (activeCommandObj) {\n            if (lowerQuery.length <= activeCommandObj.trigger.length)\n                return null;\n            searchPart = lowerQuery.replace(activeCommandObj.trigger, \"\").trim();\n            if (activeCommandObj.scope) {\n                keysToSearch = [activeCommandObj.scope];\n            }\n        }\n        if (!searchPart)\n            return null;\n        const match = data.find((item) => {\n            return keysToSearch.some((key) => {\n                const val = item[key];\n                const strVal = String(val).toLowerCase();\n                if (Array.isArray(val)) {\n                    return val.some((v) => v.toLowerCase().startsWith(searchPart));\n                }\n                return strVal.startsWith(searchPart);\n            });\n        });\n        if (match) {\n            let matchedText = \"\";\n            for (const key of keysToSearch) {\n                const val = match[key];\n                if (Array.isArray(val)) {\n                    const subMatch = val.find((v) => v.toLowerCase().startsWith(searchPart));\n                    if (subMatch) {\n                        matchedText = subMatch;\n                        break;\n                    }\n                }\n                else if (String(val).toLowerCase().startsWith(searchPart)) {\n                    matchedText = String(val);\n                    break;\n                }\n            }\n            if (matchedText) {\n                const prefix = activeCommandObj ? activeCommandObj.trigger + \" \" : \"\";\n                return { text: prefix + matchedText, isCommand: false };\n            }\n        }\n        return null;\n    }, [query, data, searchKeys, normalizedCommands, activeCommandObj]);\n    const ghostText = useMemo(() => {\n        if (!suggestionDetails || !query)\n            return \"\";\n        const fullSuggestion = suggestionDetails.text;\n        if (fullSuggestion.toLowerCase().startsWith(query.toLowerCase())) {\n            return query + fullSuggestion.slice(query.length);\n        }\n        return \"\";\n    }, [query, suggestionDetails]);\n    const filteredData = useMemo(() => {\n        let results = data;\n        const lowerQuery = query.toLowerCase();\n        if (lowerQuery.startsWith(\":\") &&\n            !lowerQuery.includes(\" \") &&\n            !activeCommandObj) {\n            return [];\n        }\n        if (activeCommandObj) {\n            if (activeCommandObj.filter) {\n                results = results.filter(activeCommandObj.filter);\n            }\n            const searchPart = lowerQuery\n                .replace(activeCommandObj.trigger, \"\")\n                .trim();\n            if (searchPart) {\n                const keysToSearch = activeCommandObj.scope\n                    ? [activeCommandObj.scope]\n                    : searchKeys;\n                results = filterList(results, keysToSearch, searchPart, fuzzy);\n            }\n        }\n        else {\n            results = filterList(results, searchKeys, lowerQuery, fuzzy);\n        }\n        return maxResults ? results.slice(0, maxResults) : results;\n    }, [query, data, searchKeys, activeCommandObj, fuzzy, maxResults]);\n    const handleChange = useCallback((e) => {\n        setQuery(e.target.value);\n    }, []);\n    const handleKeyDown = useCallback((e) => {\n        if (e.key === \"Tab\" && suggestionDetails) {\n            e.preventDefault();\n            const suffix = suggestionDetails.isCommand ? \" \" : \"\";\n            setQuery(suggestionDetails.text + suffix);\n        }\n    }, [suggestionDetails]);\n    return {\n        query,\n        setQuery,\n        filteredData,\n        ghostText,\n        isSuggestionAvailable: !!suggestionDetails,\n        activeCommand: activeCommandObj?.trigger ?? null,\n        inputProps: {\n            value: query,\n            onChange: handleChange,\n            onKeyDown: handleKeyDown,\n            placeholder: activeCommandObj\n                ? `Search in ${activeCommandObj.trigger}...`\n                : `Search or type ':' for commands...`,\n        },\n    };\n}"
  }
}