{
  "$schema": "https://raw.githubusercontent.com/sseuniverse/sse-hooks/refs/heads/main/schema/meta.json",
  "name": "use-key",
  "type": "registry:hook",
  "title": "useKey",
  "description": "The function to call",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [
    "use-isomorphic-layout-effect"
  ],
  "file": {
    "content": "import { useEffect, useRef, useState, KeyboardEvent, useMemo } from \"react\";\nimport React from \"react\";\n\nexport type KeyHandler = (event: React.KeyboardEvent) => void;\nexport type KeyConfig = {\n  action: KeyHandler;\n\n  description?: string;\n\n  category?: string;\n\n  preventDefault?: boolean;\n\n  stopPropagation?: boolean;\n\n  once?: boolean;\n\n  allowInInputs?: boolean;\n};\n\nexport type KeyMap = Record<string, KeyHandler | KeyConfig>;\nexport type UseKeyOptions = {\n  target?: React.RefObject<HTMLElement> | null;\n\n  event?: \"keydown\" | \"keyup\";\n\n  enabled?: boolean;\n\n  debug?: boolean;\n\n  sequenceTimeout?: number;\n\n  filter?: (e: React.KeyboardEvent) => boolean;\n};\n\nimport { useIsomorphicLayoutEffect } from \"./use-isomorphic-layout-effect\";\nexport const KEY_ALIASES: Record<string, string> = {\n  ctrl: \"control\",\n  opt: \"alt\",\n  option: \"alt\",\n  cmd: \"meta\",\n  command: \"meta\",\n  esc: \"escape\",\n  space: \" \",\n  \" \": \"space\",\n};\n\nexport function normalizeKeyCombo(e: React.KeyboardEvent | string): string {\n  if (typeof e === \"string\") {\n    const parts = e\n      .toLowerCase()\n      .split(\"+\")\n      .map((p) => p.trim());\n    const key = parts.pop();\n    const mods = parts.map((m) => KEY_ALIASES[m] || m).sort();\n    return [...mods, key === \" \" ? \"space\" : key].join(\"+\");\n  }\n\n  const mods = [];\n  if (e.ctrlKey) mods.push(\"control\");\n  if (e.altKey) mods.push(\"alt\");\n  if (e.metaKey) mods.push(\"meta\");\n  if (e.shiftKey) mods.push(\"shift\");\n\n  mods.sort();\n  let key = e.key.toLowerCase();\n  if (key === \" \") key = \"space\";\n\n  if ([\"control\", \"alt\", \"meta\", \"shift\"].includes(key)) {\n    return key;\n  }\n\n  return [...mods, key].join(\"+\");\n}\n\nexport function isInputTarget(e: React.KeyboardEvent): boolean {\n  const target = e.target as HTMLElement;\n  return (\n    target.isContentEditable ||\n    [\"INPUT\", \"TEXTAREA\", \"SELECT\"].includes(target.tagName)\n  );\n}\n\nexport function useKeyListener(\n  handler: (e: KeyboardEvent) => void,\n  options: UseKeyOptions = {},\n) {\n  const { target, event = \"keydown\", enabled = true } = options;\n  const handlerRef = useRef(handler);\n\n  useIsomorphicLayoutEffect(() => {\n    handlerRef.current = handler;\n  }, []);\n\n  useEffect(() => {\n    if (!enabled) return;\n\n    const node = target ? target.current : window;\n    if (!node) return;\n\n    const eventListener = (e: Event) =>\n      handlerRef.current(e as unknown as KeyboardEvent);\n    node.addEventListener(event, eventListener);\n    return () => node.removeEventListener(event, eventListener);\n  }, [target, event, enabled]);\n}\n\nexport function useKey(keyMap: KeyMap, options: UseKeyOptions = {}) {\n  const { debug = false, sequenceTimeout = 1000, filter } = options;\n  const [buffer, setBuffer] = useState<string[]>([]);\n  const timeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const firedRef = useRef<Set<string>>(new Set());\n  const callbackMapRef = useRef(keyMap);\n\n  useIsomorphicLayoutEffect(() => {\n    callbackMapRef.current = keyMap;\n  });\n\n  const handleEvent = (e: React.KeyboardEvent) => {\n    const currentCombo = normalizeKeyCombo(e);\n\n    if (debug) {\n      console.log(\n        `[useKey] Pressed: ${e.key} | Normalized: ${currentCombo} | Buffer: ${buffer.join(\" \")}`,\n      );\n    }\n\n    if (filter && !filter(e)) return;\n\n    const nextBuffer = [...buffer, currentCombo];\n    if (timeoutRef.current) clearTimeout(timeoutRef.current);\n    timeoutRef.current = setTimeout(() => setBuffer([]), sequenceTimeout);\n    setBuffer(nextBuffer);\n\n    const sequenceKey = nextBuffer.join(\" \");\n    Object.entries(callbackMapRef.current).forEach(([keyBinding, value]) => {\n      const normalizedBinding = keyBinding\n        .split(\" \")\n        .map(normalizeKeyCombo)\n        .join(\" \");\n\n      const config: KeyConfig =\n        typeof value === \"function\" ? { action: value } : value;\n\n      let isMatch = false;\n      if (normalizedBinding === sequenceKey) {\n        isMatch = true;\n        setBuffer([]);\n      } else if (\n        normalizedBinding === currentCombo &&\n        nextBuffer.length === 1\n      ) {\n        isMatch = true;\n      }\n\n      if (isMatch) {\n        if (config.once && firedRef.current.has(normalizedBinding)) return;\n        if (!config.allowInInputs && isInputTarget(e)) return;\n\n        if (config.preventDefault) e.preventDefault();\n        if (config.stopPropagation) e.stopPropagation();\n        if (config.once) firedRef.current.add(normalizedBinding);\n\n        if (debug) console.log(`[useKey] Triggered: ${keyBinding}`);\n\n        config.action(e);\n      }\n    });\n  };\n\n  useKeyListener(handleEvent, options);\n\n  const bindings = useMemo(() => {\n    return Object.entries(keyMap).map(([keys, value]) => {\n      const config = typeof value === \"function\" ? ({} as KeyConfig) : value;\n      return {\n        keys,\n        category: config.category || \"General\",\n        description: config.description || \"No description\",\n      };\n    });\n  }, [keyMap]);\n\n  return { bindings };\n}\n",
    "js": "import { useEffect, useRef, useState, useMemo } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"./use-isomorphic-layout-effect\";\nexport const KEY_ALIASES = {\n    ctrl: \"control\",\n    opt: \"alt\",\n    option: \"alt\",\n    cmd: \"meta\",\n    command: \"meta\",\n    esc: \"escape\",\n    space: \" \",\n    \" \": \"space\",\n};\nexport function normalizeKeyCombo(e) {\n    if (typeof e === \"string\") {\n        const parts = e\n            .toLowerCase()\n            .split(\"+\")\n            .map((p) => p.trim());\n        const key = parts.pop();\n        const mods = parts.map((m) => KEY_ALIASES[m] || m).sort();\n        return [...mods, key === \" \" ? \"space\" : key].join(\"+\");\n    }\n    const mods = [];\n    if (e.ctrlKey)\n        mods.push(\"control\");\n    if (e.altKey)\n        mods.push(\"alt\");\n    if (e.metaKey)\n        mods.push(\"meta\");\n    if (e.shiftKey)\n        mods.push(\"shift\");\n    mods.sort();\n    let key = e.key.toLowerCase();\n    if (key === \" \")\n        key = \"space\";\n    if ([\"control\", \"alt\", \"meta\", \"shift\"].includes(key)) {\n        return key;\n    }\n    return [...mods, key].join(\"+\");\n}\nexport function isInputTarget(e) {\n    const target = e.target;\n    return (target.isContentEditable ||\n        [\"INPUT\", \"TEXTAREA\", \"SELECT\"].includes(target.tagName));\n}\nexport function useKeyListener(handler, options = {}) {\n    const { target, event = \"keydown\", enabled = true } = options;\n    const handlerRef = useRef(handler);\n    useIsomorphicLayoutEffect(() => {\n        handlerRef.current = handler;\n    }, []);\n    useEffect(() => {\n        if (!enabled)\n            return;\n        const node = target ? target.current : window;\n        if (!node)\n            return;\n        const eventListener = (e) => handlerRef.current(e);\n        node.addEventListener(event, eventListener);\n        return () => node.removeEventListener(event, eventListener);\n    }, [target, event, enabled]);\n}\nexport function useKey(keyMap, options = {}) {\n    const { debug = false, sequenceTimeout = 1000, filter } = options;\n    const [buffer, setBuffer] = useState([]);\n    const timeoutRef = useRef(null);\n    const firedRef = useRef(new Set());\n    const callbackMapRef = useRef(keyMap);\n    useIsomorphicLayoutEffect(() => {\n        callbackMapRef.current = keyMap;\n    });\n    const handleEvent = (e) => {\n        const currentCombo = normalizeKeyCombo(e);\n        if (debug) {\n            console.log(`[useKey] Pressed: ${e.key} | Normalized: ${currentCombo} | Buffer: ${buffer.join(\" \")}`);\n        }\n        if (filter && !filter(e))\n            return;\n        const nextBuffer = [...buffer, currentCombo];\n        if (timeoutRef.current)\n            clearTimeout(timeoutRef.current);\n        timeoutRef.current = setTimeout(() => setBuffer([]), sequenceTimeout);\n        setBuffer(nextBuffer);\n        const sequenceKey = nextBuffer.join(\" \");\n        Object.entries(callbackMapRef.current).forEach(([keyBinding, value]) => {\n            const normalizedBinding = keyBinding\n                .split(\" \")\n                .map(normalizeKeyCombo)\n                .join(\" \");\n            const config = typeof value === \"function\" ? { action: value } : value;\n            let isMatch = false;\n            if (normalizedBinding === sequenceKey) {\n                isMatch = true;\n                setBuffer([]);\n            }\n            else if (normalizedBinding === currentCombo &&\n                nextBuffer.length === 1) {\n                isMatch = true;\n            }\n            if (isMatch) {\n                if (config.once && firedRef.current.has(normalizedBinding))\n                    return;\n                if (!config.allowInInputs && isInputTarget(e))\n                    return;\n                if (config.preventDefault)\n                    e.preventDefault();\n                if (config.stopPropagation)\n                    e.stopPropagation();\n                if (config.once)\n                    firedRef.current.add(normalizedBinding);\n                if (debug)\n                    console.log(`[useKey] Triggered: ${keyBinding}`);\n                config.action(e);\n            }\n        });\n    };\n    useKeyListener(handleEvent, options);\n    const bindings = useMemo(() => {\n        return Object.entries(keyMap).map(([keys, value]) => {\n            const config = typeof value === \"function\" ? {} : value;\n            return {\n                keys,\n                category: config.category || \"General\",\n                description: config.description || \"No description\",\n            };\n        });\n    }, [keyMap]);\n    return { bindings };\n}"
  }
}