{
  "$schema": "https://sse-hooks.vercel.app/api/registry/schema/hook.json",
  "name": "use-symbol",
  "type": "registry:hook",
  "title": "useSymbol",
  "description": "Creates a new unique symbol and adds it to the local registry.",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [],
  "file": {
    "content": "export interface UseSymbolReturn {\n  createSymbol: (description?: string) => symbol;\n\n  getGlobalSymbol: (key: string) => symbol;\n\n  getSymbolKey: (symbol: symbol) => string | undefined;\n\n  isSymbol: (value: any) => value is symbol;\n\n  getDescription: (symbol: symbol) => string | undefined;\n\n  wellKnownSymbols: {\n    iterator: symbol;\n    asyncIterator: symbol;\n    hasInstance: symbol;\n    isConcatSpreadable: symbol;\n    species: symbol;\n    toPrimitive: symbol;\n    toStringTag: symbol;\n    unscopables: symbol;\n    match: symbol;\n    matchAll: symbol;\n    replace: symbol;\n    search: symbol;\n    split: symbol;\n  };\n\n  symbols: symbol[];\n\n  addSymbol: (symbol: symbol) => void;\n\n  removeSymbol: (symbol: symbol) => void;\n\n  clearSymbols: () => void;\n}\n\nimport { useState, useCallback, useMemo, useRef } from \"react\";\n\nexport function useSymbol(): UseSymbolReturn {\n  const [symbols, setSymbols] = useState<symbol[]>([]);\n  const symbolsRef = useRef<Set<symbol>>(new Set());\n\n  const createSymbol = useCallback((description?: string): symbol => {\n    const newSymbol = Symbol(description);\n    setSymbols((prev) => [...prev, newSymbol]);\n    symbolsRef.current.add(newSymbol);\n    return newSymbol;\n  }, []);\n\n  const getGlobalSymbol = useCallback((key: string): symbol => {\n    return Symbol.for(key);\n  }, []);\n\n  const getSymbolKey = useCallback((symbol: symbol): string | undefined => {\n    return Symbol.keyFor(symbol);\n  }, []);\n\n  const isSymbol = useCallback((value: any): value is symbol => {\n    return typeof value === \"symbol\";\n  }, []);\n\n  const getDescription = useCallback((symbol: symbol): string | undefined => {\n    return symbol.description;\n  }, []);\n\n  const addSymbol = useCallback((symbol: symbol) => {\n    if (!symbolsRef.current.has(symbol)) {\n      setSymbols((prev) => [...prev, symbol]);\n      symbolsRef.current.add(symbol);\n    }\n  }, []);\n\n  const removeSymbol = useCallback((symbol: symbol) => {\n    if (symbolsRef.current.has(symbol)) {\n      setSymbols((prev) => prev.filter((s) => s !== symbol));\n      symbolsRef.current.delete(symbol);\n    }\n  }, []);\n\n  const clearSymbols = useCallback(() => {\n    setSymbols([]);\n    symbolsRef.current.clear();\n  }, []);\n\n  const wellKnownSymbols = useMemo(\n    () => ({\n      iterator: Symbol.iterator,\n      asyncIterator: Symbol.asyncIterator,\n      hasInstance: Symbol.hasInstance,\n      isConcatSpreadable: Symbol.isConcatSpreadable,\n      species: Symbol.species,\n      toPrimitive: Symbol.toPrimitive,\n      toStringTag: Symbol.toStringTag,\n      unscopables: Symbol.unscopables,\n      match: Symbol.match,\n      matchAll: Symbol.matchAll,\n      replace: Symbol.replace,\n      search: Symbol.search,\n      split: Symbol.split,\n    }),\n    [],\n  );\n\n  return {\n    createSymbol,\n    getGlobalSymbol,\n    getSymbolKey,\n    isSymbol,\n    getDescription,\n    wellKnownSymbols,\n    symbols,\n    addSymbol,\n    removeSymbol,\n    clearSymbols,\n  };\n}\n",
    "js": "import { useState, useCallback, useMemo, useRef } from \"react\";\nexport function useSymbol() {\n    const [symbols, setSymbols] = useState([]);\n    const symbolsRef = useRef(new Set());\n    const createSymbol = useCallback((description) => {\n        const newSymbol = Symbol(description);\n        setSymbols((prev) => [...prev, newSymbol]);\n        symbolsRef.current.add(newSymbol);\n        return newSymbol;\n    }, []);\n    const getGlobalSymbol = useCallback((key) => {\n        return Symbol.for(key);\n    }, []);\n    const getSymbolKey = useCallback((symbol) => {\n        return Symbol.keyFor(symbol);\n    }, []);\n    const isSymbol = useCallback((value) => {\n        return typeof value === \"symbol\";\n    }, []);\n    const getDescription = useCallback((symbol) => {\n        return symbol.description;\n    }, []);\n    const addSymbol = useCallback((symbol) => {\n        if (!symbolsRef.current.has(symbol)) {\n            setSymbols((prev) => [...prev, symbol]);\n            symbolsRef.current.add(symbol);\n        }\n    }, []);\n    const removeSymbol = useCallback((symbol) => {\n        if (symbolsRef.current.has(symbol)) {\n            setSymbols((prev) => prev.filter((s) => s !== symbol));\n            symbolsRef.current.delete(symbol);\n        }\n    }, []);\n    const clearSymbols = useCallback(() => {\n        setSymbols([]);\n        symbolsRef.current.clear();\n    }, []);\n    const wellKnownSymbols = useMemo(() => ({\n        iterator: Symbol.iterator,\n        asyncIterator: Symbol.asyncIterator,\n        hasInstance: Symbol.hasInstance,\n        isConcatSpreadable: Symbol.isConcatSpreadable,\n        species: Symbol.species,\n        toPrimitive: Symbol.toPrimitive,\n        toStringTag: Symbol.toStringTag,\n        unscopables: Symbol.unscopables,\n        match: Symbol.match,\n        matchAll: Symbol.matchAll,\n        replace: Symbol.replace,\n        search: Symbol.search,\n        split: Symbol.split,\n    }), []);\n    return {\n        createSymbol,\n        getGlobalSymbol,\n        getSymbolKey,\n        isSymbol,\n        getDescription,\n        wellKnownSymbols,\n        symbols,\n        addSymbol,\n        removeSymbol,\n        clearSymbols,\n    };\n}"
  }
}