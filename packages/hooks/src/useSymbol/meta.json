{
  "$schema": "https://raw.githubusercontent.com/sseuniverse/sse-hooks/refs/heads/main/schema/meta.json",
  "name": "use-symbol",
  "type": "registry:hook",
  "title": "useSymbol",
  "description": "",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [],
  "file": {
    "content": "export interface UseSymbolReturn {\r\n  \r\n  createSymbol: (description?: string) => symbol;\r\n\r\n  \r\n  getGlobalSymbol: (key: string) => symbol;\r\n  getSymbolKey: (symbol: symbol) => string | undefined;\r\n\r\n  \r\n  isSymbol: (value: any) => value is symbol;\r\n  getDescription: (symbol: symbol) => string | undefined;\r\n\r\n  \r\n  wellKnownSymbols: {\r\n    iterator: symbol;\r\n    asyncIterator: symbol;\r\n    hasInstance: symbol;\r\n    isConcatSpreadable: symbol;\r\n    species: symbol;\r\n    toPrimitive: symbol;\r\n    toStringTag: symbol;\r\n    unscopables: symbol;\r\n    match: symbol;\r\n    matchAll: symbol;\r\n    replace: symbol;\r\n    search: symbol;\r\n    split: symbol;\r\n  };\r\n\r\n  \r\n  symbols: symbol[];\r\n  addSymbol: (symbol: symbol) => void;\r\n  removeSymbol: (symbol: symbol) => void;\r\n  clearSymbols: () => void;\r\n}\r\n\nimport { useState, useCallback, useMemo, useRef } from \"react\";\r\n\nexport function useSymbol(): UseSymbolReturn {\r\n  const [symbols, setSymbols] = useState<symbol[]>([]);\r\n  const symbolsRef = useRef<Set<symbol>>(new Set());\r\n\r\n  const createSymbol = useCallback((description?: string): symbol => {\r\n    const newSymbol = Symbol(description);\r\n    setSymbols((prev) => [...prev, newSymbol]);\r\n    symbolsRef.current.add(newSymbol);\r\n    return newSymbol;\r\n  }, []);\r\n\r\n  const getGlobalSymbol = useCallback((key: string): symbol => {\r\n    return Symbol.for(key);\r\n  }, []);\r\n\r\n  const getSymbolKey = useCallback((symbol: symbol): string | undefined => {\r\n    return Symbol.keyFor(symbol);\r\n  }, []);\r\n\r\n  const isSymbol = useCallback((value: any): value is symbol => {\r\n    return typeof value === \"symbol\";\r\n  }, []);\r\n\r\n  const getDescription = useCallback((symbol: symbol): string | undefined => {\r\n    return symbol.description;\r\n  }, []);\r\n\r\n  const addSymbol = useCallback((symbol: symbol) => {\r\n    if (!symbolsRef.current.has(symbol)) {\r\n      setSymbols((prev) => [...prev, symbol]);\r\n      symbolsRef.current.add(symbol);\r\n    }\r\n  }, []);\r\n\r\n  const removeSymbol = useCallback((symbol: symbol) => {\r\n    if (symbolsRef.current.has(symbol)) {\r\n      setSymbols((prev) => prev.filter((s) => s !== symbol));\r\n      symbolsRef.current.delete(symbol);\r\n    }\r\n  }, []);\r\n\r\n  const clearSymbols = useCallback(() => {\r\n    setSymbols([]);\r\n    symbolsRef.current.clear();\r\n  }, []);\r\n\r\n  const wellKnownSymbols = useMemo(\r\n    () => ({\r\n      iterator: Symbol.iterator,\r\n      asyncIterator: Symbol.asyncIterator,\r\n      hasInstance: Symbol.hasInstance,\r\n      isConcatSpreadable: Symbol.isConcatSpreadable,\r\n      species: Symbol.species,\r\n      toPrimitive: Symbol.toPrimitive,\r\n      toStringTag: Symbol.toStringTag,\r\n      unscopables: Symbol.unscopables,\r\n      match: Symbol.match,\r\n      matchAll: Symbol.matchAll,\r\n      replace: Symbol.replace,\r\n      search: Symbol.search,\r\n      split: Symbol.split,\r\n    }),\r\n    [],\r\n  );\r\n\r\n  return {\r\n    createSymbol,\r\n    getGlobalSymbol,\r\n    getSymbolKey,\r\n    isSymbol,\r\n    getDescription,\r\n    wellKnownSymbols,\r\n    symbols,\r\n    addSymbol,\r\n    removeSymbol,\r\n    clearSymbols,\r\n  };\r\n}",
    "js": "import { useState, useCallback, useMemo, useRef } from \"react\";\nexport function useSymbol() {\n    const [symbols, setSymbols] = useState([]);\n    const symbolsRef = useRef(new Set());\n    const createSymbol = useCallback((description) => {\n        const newSymbol = Symbol(description);\n        setSymbols((prev) => [...prev, newSymbol]);\n        symbolsRef.current.add(newSymbol);\n        return newSymbol;\n    }, []);\n    const getGlobalSymbol = useCallback((key) => {\n        return Symbol.for(key);\n    }, []);\n    const getSymbolKey = useCallback((symbol) => {\n        return Symbol.keyFor(symbol);\n    }, []);\n    const isSymbol = useCallback((value) => {\n        return typeof value === \"symbol\";\n    }, []);\n    const getDescription = useCallback((symbol) => {\n        return symbol.description;\n    }, []);\n    const addSymbol = useCallback((symbol) => {\n        if (!symbolsRef.current.has(symbol)) {\n            setSymbols((prev) => [...prev, symbol]);\n            symbolsRef.current.add(symbol);\n        }\n    }, []);\n    const removeSymbol = useCallback((symbol) => {\n        if (symbolsRef.current.has(symbol)) {\n            setSymbols((prev) => prev.filter((s) => s !== symbol));\n            symbolsRef.current.delete(symbol);\n        }\n    }, []);\n    const clearSymbols = useCallback(() => {\n        setSymbols([]);\n        symbolsRef.current.clear();\n    }, []);\n    const wellKnownSymbols = useMemo(() => ({\n        iterator: Symbol.iterator,\n        asyncIterator: Symbol.asyncIterator,\n        hasInstance: Symbol.hasInstance,\n        isConcatSpreadable: Symbol.isConcatSpreadable,\n        species: Symbol.species,\n        toPrimitive: Symbol.toPrimitive,\n        toStringTag: Symbol.toStringTag,\n        unscopables: Symbol.unscopables,\n        match: Symbol.match,\n        matchAll: Symbol.matchAll,\n        replace: Symbol.replace,\n        search: Symbol.search,\n        split: Symbol.split,\n    }), []);\n    return {\n        createSymbol,\n        getGlobalSymbol,\n        getSymbolKey,\n        isSymbol,\n        getDescription,\n        wellKnownSymbols,\n        symbols,\n        addSymbol,\n        removeSymbol,\n        clearSymbols,\n    };\n}"
  }
}