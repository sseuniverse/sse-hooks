{
  "$schema": "https://sse-hooks.vercel.app/api/registry/schema/hook.json",
  "name": "use-indexed-db",
  "type": "registry:hook",
  "title": "useIndexedDB",
  "description": "Options for configuring the IndexedDB connection and behavior.",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [],
  "file": {
    "content": "import { useState, useEffect, useCallback } from \"react\";\n\ninterface UseIndexedDBOptions {\n  version?: number;\n\n  onUpgradeNeeded?: (\n    db: IDBDatabase,\n    oldVersion: number,\n    newVersion: number,\n  ) => void;\n}\n\ninterface UseIndexedDBReturn<T> {\n  data: T | null;\n\n  error: string | null;\n\n  loading: boolean;\n\n  setItem: (key: string, value: T) => Promise<void>;\n\n  getItem: (key: string) => Promise<T | null>;\n\n  removeItem: (key: string) => Promise<void>;\n\n  clear: () => Promise<void>;\n\n  getAllKeys: () => Promise<string[]>;\n}\n\nexport function useIndexedDB<T>(\n  databaseName: string,\n  storeName: string,\n  options: UseIndexedDBOptions = {},\n): UseIndexedDBReturn<T> {\n  const [data, setData] = useState<T | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  const [loading, setLoading] = useState<boolean>(false);\n  const [db, setDb] = useState<IDBDatabase | null>(null);\n\n  const { version = 1, onUpgradeNeeded } = options;\n\n  useEffect(() => {\n    if (typeof window === \"undefined\") return;\n\n    const initDB = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n\n        const request = indexedDB.open(databaseName, version);\n\n        request.onerror = () => {\n          setError(`Failed to open database: ${request.error?.message}`);\n          setLoading(false);\n        };\n\n        request.onsuccess = () => {\n          setDb(request.result);\n          setLoading(false);\n        };\n\n        request.onupgradeneeded = (event) => {\n          const database = request.result;\n          const oldVersion = event.oldVersion;\n          const newVersion = event.newVersion || version;\n\n          if (!database.objectStoreNames.contains(storeName)) {\n            database.createObjectStore(storeName);\n          }\n\n          if (onUpgradeNeeded) {\n            onUpgradeNeeded(database, oldVersion, newVersion);\n          }\n        };\n      } catch (err) {\n        setError(`IndexedDB initialization error: ${err}`);\n        setLoading(false);\n      }\n    };\n\n    initDB();\n\n    return () => {\n      if (db) {\n        db.close();\n      }\n    };\n  }, [databaseName, storeName, version, onUpgradeNeeded]);\n\n  const setItem = useCallback(\n    async (key: string, value: T): Promise<void> => {\n      if (!db) {\n        throw new Error(\"Database not initialized\");\n      }\n\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([storeName], \"readwrite\");\n        const store = transaction.objectStore(storeName);\n        const request = store.put(value, key);\n\n        request.onsuccess = () => {\n          setData(value);\n          resolve();\n        };\n\n        request.onerror = () => {\n          const errorMsg = `Failed to set item: ${request.error?.message}`;\n          setError(errorMsg);\n          reject(new Error(errorMsg));\n        };\n      });\n    },\n    [db, storeName],\n  );\n\n  const getItem = useCallback(\n    async (key: string): Promise<T | null> => {\n      if (!db) {\n        throw new Error(\"Database not initialized\");\n      }\n\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([storeName], \"readonly\");\n        const store = transaction.objectStore(storeName);\n        const request = store.get(key);\n\n        request.onsuccess = () => {\n          const result = request.result || null;\n          setData(result);\n          resolve(result);\n        };\n\n        request.onerror = () => {\n          const errorMsg = `Failed to get item: ${request.error?.message}`;\n          setError(errorMsg);\n          reject(new Error(errorMsg));\n        };\n      });\n    },\n    [db, storeName],\n  );\n\n  const removeItem = useCallback(\n    async (key: string): Promise<void> => {\n      if (!db) {\n        throw new Error(\"Database not initialized\");\n      }\n\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([storeName], \"readwrite\");\n        const store = transaction.objectStore(storeName);\n        const request = store.delete(key);\n\n        request.onsuccess = () => {\n          setData(null);\n          resolve();\n        };\n\n        request.onerror = () => {\n          const errorMsg = `Failed to remove item: ${request.error?.message}`;\n          setError(errorMsg);\n          reject(new Error(errorMsg));\n        };\n      });\n    },\n    [db, storeName],\n  );\n\n  const clear = useCallback(async (): Promise<void> => {\n    if (!db) {\n      throw new Error(\"Database not initialized\");\n    }\n\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([storeName], \"readwrite\");\n      const store = transaction.objectStore(storeName);\n      const request = store.clear();\n\n      request.onsuccess = () => {\n        setData(null);\n        resolve();\n      };\n\n      request.onerror = () => {\n        const errorMsg = `Failed to clear store: ${request.error?.message}`;\n        setError(errorMsg);\n        reject(new Error(errorMsg));\n      };\n    });\n  }, [db, storeName]);\n\n  const getAllKeys = useCallback(async (): Promise<string[]> => {\n    if (!db) {\n      throw new Error(\"Database not initialized\");\n    }\n\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([storeName], \"readonly\");\n      const store = transaction.objectStore(storeName);\n      const request = store.getAllKeys();\n\n      request.onsuccess = () => {\n        resolve(request.result as string[]);\n      };\n\n      request.onerror = () => {\n        const errorMsg = `Failed to get keys: ${request.error?.message}`;\n        setError(errorMsg);\n        reject(new Error(errorMsg));\n      };\n    });\n  }, [db, storeName]);\n\n  return {\n    data,\n    error,\n    loading,\n    setItem,\n    getItem,\n    removeItem,\n    clear,\n    getAllKeys,\n  };\n}\n",
    "js": "import { useState, useEffect, useCallback } from \"react\";\nexport function useIndexedDB(databaseName, storeName, options = {}) {\n    const [data, setData] = useState(null);\n    const [error, setError] = useState(null);\n    const [loading, setLoading] = useState(false);\n    const [db, setDb] = useState(null);\n    const { version = 1, onUpgradeNeeded } = options;\n    useEffect(() => {\n        if (typeof window === \"undefined\")\n            return;\n        const initDB = async () => {\n            try {\n                setLoading(true);\n                setError(null);\n                const request = indexedDB.open(databaseName, version);\n                request.onerror = () => {\n                    setError(`Failed to open database: ${request.error?.message}`);\n                    setLoading(false);\n                };\n                request.onsuccess = () => {\n                    setDb(request.result);\n                    setLoading(false);\n                };\n                request.onupgradeneeded = (event) => {\n                    const database = request.result;\n                    const oldVersion = event.oldVersion;\n                    const newVersion = event.newVersion || version;\n                    if (!database.objectStoreNames.contains(storeName)) {\n                        database.createObjectStore(storeName);\n                    }\n                    if (onUpgradeNeeded) {\n                        onUpgradeNeeded(database, oldVersion, newVersion);\n                    }\n                };\n            }\n            catch (err) {\n                setError(`IndexedDB initialization error: ${err}`);\n                setLoading(false);\n            }\n        };\n        initDB();\n        return () => {\n            if (db) {\n                db.close();\n            }\n        };\n    }, [databaseName, storeName, version, onUpgradeNeeded]);\n    const setItem = useCallback(async (key, value) => {\n        if (!db) {\n            throw new Error(\"Database not initialized\");\n        }\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction([storeName], \"readwrite\");\n            const store = transaction.objectStore(storeName);\n            const request = store.put(value, key);\n            request.onsuccess = () => {\n                setData(value);\n                resolve();\n            };\n            request.onerror = () => {\n                const errorMsg = `Failed to set item: ${request.error?.message}`;\n                setError(errorMsg);\n                reject(new Error(errorMsg));\n            };\n        });\n    }, [db, storeName]);\n    const getItem = useCallback(async (key) => {\n        if (!db) {\n            throw new Error(\"Database not initialized\");\n        }\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction([storeName], \"readonly\");\n            const store = transaction.objectStore(storeName);\n            const request = store.get(key);\n            request.onsuccess = () => {\n                const result = request.result || null;\n                setData(result);\n                resolve(result);\n            };\n            request.onerror = () => {\n                const errorMsg = `Failed to get item: ${request.error?.message}`;\n                setError(errorMsg);\n                reject(new Error(errorMsg));\n            };\n        });\n    }, [db, storeName]);\n    const removeItem = useCallback(async (key) => {\n        if (!db) {\n            throw new Error(\"Database not initialized\");\n        }\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction([storeName], \"readwrite\");\n            const store = transaction.objectStore(storeName);\n            const request = store.delete(key);\n            request.onsuccess = () => {\n                setData(null);\n                resolve();\n            };\n            request.onerror = () => {\n                const errorMsg = `Failed to remove item: ${request.error?.message}`;\n                setError(errorMsg);\n                reject(new Error(errorMsg));\n            };\n        });\n    }, [db, storeName]);\n    const clear = useCallback(async () => {\n        if (!db) {\n            throw new Error(\"Database not initialized\");\n        }\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction([storeName], \"readwrite\");\n            const store = transaction.objectStore(storeName);\n            const request = store.clear();\n            request.onsuccess = () => {\n                setData(null);\n                resolve();\n            };\n            request.onerror = () => {\n                const errorMsg = `Failed to clear store: ${request.error?.message}`;\n                setError(errorMsg);\n                reject(new Error(errorMsg));\n            };\n        });\n    }, [db, storeName]);\n    const getAllKeys = useCallback(async () => {\n        if (!db) {\n            throw new Error(\"Database not initialized\");\n        }\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction([storeName], \"readonly\");\n            const store = transaction.objectStore(storeName);\n            const request = store.getAllKeys();\n            request.onsuccess = () => {\n                resolve(request.result);\n            };\n            request.onerror = () => {\n                const errorMsg = `Failed to get keys: ${request.error?.message}`;\n                setError(errorMsg);\n                reject(new Error(errorMsg));\n            };\n        });\n    }, [db, storeName]);\n    return {\n        data,\n        error,\n        loading,\n        setItem,\n        getItem,\n        removeItem,\n        clear,\n        getAllKeys,\n    };\n}"
  }
}