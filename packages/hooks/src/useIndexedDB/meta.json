{
  "$schema": "https://raw.githubusercontent.com/sseuniverse/sse-hooks/refs/heads/main/schema/meta.json",
  "name": "use-indexed-db",
  "type": "registry:hook",
  "title": "useIndexedDB",
  "description": "Options for configuring the IndexedDB connection and behavior.",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [],
  "file": {
    "content": "import { useState, useEffect, useCallback } from \"react\";\r\n\r\n\r\ninterface UseIndexedDBOptions {\r\n  \r\n  version?: number;\r\n  \r\n  onUpgradeNeeded?: (\r\n    db: IDBDatabase,\r\n    oldVersion: number,\r\n    newVersion: number,\r\n  ) => void;\r\n}\r\n\r\n\r\ninterface UseIndexedDBReturn<T> {\r\n  \r\n  data: T | null;\r\n  \r\n  error: string | null;\r\n  \r\n  loading: boolean;\r\n  \r\n  setItem: (key: string, value: T) => Promise<void>;\r\n  \r\n  getItem: (key: string) => Promise<T | null>;\r\n  \r\n  removeItem: (key: string) => Promise<void>;\r\n  \r\n  clear: () => Promise<void>;\r\n  \r\n  getAllKeys: () => Promise<string[]>;\r\n}\r\n\r\n\r\nexport function useIndexedDB<T>(\r\n  databaseName: string,\r\n  storeName: string,\r\n  options: UseIndexedDBOptions = {},\r\n): UseIndexedDBReturn<T> {\r\n  const [data, setData] = useState<T | null>(null);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const [loading, setLoading] = useState<boolean>(false);\r\n  const [db, setDb] = useState<IDBDatabase | null>(null);\r\n\r\n  const { version = 1, onUpgradeNeeded } = options;\r\n\r\n  \r\n  useEffect(() => {\r\n    if (typeof window === \"undefined\") return;\r\n\r\n    const initDB = async () => {\r\n      try {\r\n        setLoading(true);\r\n        setError(null);\r\n\r\n        const request = indexedDB.open(databaseName, version);\r\n\r\n        request.onerror = () => {\r\n          setError(`Failed to open database: ${request.error?.message}`);\r\n          setLoading(false);\r\n        };\r\n\r\n        request.onsuccess = () => {\r\n          setDb(request.result);\r\n          setLoading(false);\r\n        };\r\n\r\n        request.onupgradeneeded = (event) => {\r\n          const database = request.result;\r\n          const oldVersion = event.oldVersion;\r\n          const newVersion = event.newVersion || version;\r\n\r\n          \r\n          if (!database.objectStoreNames.contains(storeName)) {\r\n            database.createObjectStore(storeName);\r\n          }\r\n\r\n          \r\n          if (onUpgradeNeeded) {\r\n            onUpgradeNeeded(database, oldVersion, newVersion);\r\n          }\r\n        };\r\n      } catch (err) {\r\n        setError(`IndexedDB initialization error: ${err}`);\r\n        setLoading(false);\r\n      }\r\n    };\r\n\r\n    initDB();\r\n\r\n    return () => {\r\n      if (db) {\r\n        db.close();\r\n      }\r\n    };\r\n  }, [databaseName, storeName, version, onUpgradeNeeded]);\r\n\r\n  \r\n  const setItem = useCallback(\r\n    async (key: string, value: T): Promise<void> => {\r\n      if (!db) {\r\n        throw new Error(\"Database not initialized\");\r\n      }\r\n\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = db.transaction([storeName], \"readwrite\");\r\n        const store = transaction.objectStore(storeName);\r\n        const request = store.put(value, key);\r\n\r\n        request.onsuccess = () => {\r\n          setData(value);\r\n          resolve();\r\n        };\r\n\r\n        request.onerror = () => {\r\n          const errorMsg = `Failed to set item: ${request.error?.message}`;\r\n          setError(errorMsg);\r\n          reject(new Error(errorMsg));\r\n        };\r\n      });\r\n    },\r\n    [db, storeName],\r\n  );\r\n\r\n  \r\n  const getItem = useCallback(\r\n    async (key: string): Promise<T | null> => {\r\n      if (!db) {\r\n        throw new Error(\"Database not initialized\");\r\n      }\r\n\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = db.transaction([storeName], \"readonly\");\r\n        const store = transaction.objectStore(storeName);\r\n        const request = store.get(key);\r\n\r\n        request.onsuccess = () => {\r\n          const result = request.result || null;\r\n          setData(result);\r\n          resolve(result);\r\n        };\r\n\r\n        request.onerror = () => {\r\n          const errorMsg = `Failed to get item: ${request.error?.message}`;\r\n          setError(errorMsg);\r\n          reject(new Error(errorMsg));\r\n        };\r\n      });\r\n    },\r\n    [db, storeName],\r\n  );\r\n\r\n  \r\n  const removeItem = useCallback(\r\n    async (key: string): Promise<void> => {\r\n      if (!db) {\r\n        throw new Error(\"Database not initialized\");\r\n      }\r\n\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = db.transaction([storeName], \"readwrite\");\r\n        const store = transaction.objectStore(storeName);\r\n        const request = store.delete(key);\r\n\r\n        request.onsuccess = () => {\r\n          setData(null);\r\n          resolve();\r\n        };\r\n\r\n        request.onerror = () => {\r\n          const errorMsg = `Failed to remove item: ${request.error?.message}`;\r\n          setError(errorMsg);\r\n          reject(new Error(errorMsg));\r\n        };\r\n      });\r\n    },\r\n    [db, storeName],\r\n  );\r\n\r\n  \r\n  const clear = useCallback(async (): Promise<void> => {\r\n    if (!db) {\r\n      throw new Error(\"Database not initialized\");\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction([storeName], \"readwrite\");\r\n      const store = transaction.objectStore(storeName);\r\n      const request = store.clear();\r\n\r\n      request.onsuccess = () => {\r\n        setData(null);\r\n        resolve();\r\n      };\r\n\r\n      request.onerror = () => {\r\n        const errorMsg = `Failed to clear store: ${request.error?.message}`;\r\n        setError(errorMsg);\r\n        reject(new Error(errorMsg));\r\n      };\r\n    });\r\n  }, [db, storeName]);\r\n\r\n  \r\n  const getAllKeys = useCallback(async (): Promise<string[]> => {\r\n    if (!db) {\r\n      throw new Error(\"Database not initialized\");\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction([storeName], \"readonly\");\r\n      const store = transaction.objectStore(storeName);\r\n      const request = store.getAllKeys();\r\n\r\n      request.onsuccess = () => {\r\n        resolve(request.result as string[]);\r\n      };\r\n\r\n      request.onerror = () => {\r\n        const errorMsg = `Failed to get keys: ${request.error?.message}`;\r\n        setError(errorMsg);\r\n        reject(new Error(errorMsg));\r\n      };\r\n    });\r\n  }, [db, storeName]);\r\n\r\n  return {\r\n    data,\r\n    error,\r\n    loading,\r\n    setItem,\r\n    getItem,\r\n    removeItem,\r\n    clear,\r\n    getAllKeys,\r\n  };\r\n}",
    "js": "import { useState, useEffect, useCallback } from \"react\";\nexport function useIndexedDB(databaseName, storeName, options = {}) {\n    const [data, setData] = useState(null);\n    const [error, setError] = useState(null);\n    const [loading, setLoading] = useState(false);\n    const [db, setDb] = useState(null);\n    const { version = 1, onUpgradeNeeded } = options;\n    useEffect(() => {\n        if (typeof window === \"undefined\")\n            return;\n        const initDB = async () => {\n            try {\n                setLoading(true);\n                setError(null);\n                const request = indexedDB.open(databaseName, version);\n                request.onerror = () => {\n                    setError(`Failed to open database: ${request.error?.message}`);\n                    setLoading(false);\n                };\n                request.onsuccess = () => {\n                    setDb(request.result);\n                    setLoading(false);\n                };\n                request.onupgradeneeded = (event) => {\n                    const database = request.result;\n                    const oldVersion = event.oldVersion;\n                    const newVersion = event.newVersion || version;\n                    if (!database.objectStoreNames.contains(storeName)) {\n                        database.createObjectStore(storeName);\n                    }\n                    if (onUpgradeNeeded) {\n                        onUpgradeNeeded(database, oldVersion, newVersion);\n                    }\n                };\n            }\n            catch (err) {\n                setError(`IndexedDB initialization error: ${err}`);\n                setLoading(false);\n            }\n        };\n        initDB();\n        return () => {\n            if (db) {\n                db.close();\n            }\n        };\n    }, [databaseName, storeName, version, onUpgradeNeeded]);\n    const setItem = useCallback(async (key, value) => {\n        if (!db) {\n            throw new Error(\"Database not initialized\");\n        }\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction([storeName], \"readwrite\");\n            const store = transaction.objectStore(storeName);\n            const request = store.put(value, key);\n            request.onsuccess = () => {\n                setData(value);\n                resolve();\n            };\n            request.onerror = () => {\n                const errorMsg = `Failed to set item: ${request.error?.message}`;\n                setError(errorMsg);\n                reject(new Error(errorMsg));\n            };\n        });\n    }, [db, storeName]);\n    const getItem = useCallback(async (key) => {\n        if (!db) {\n            throw new Error(\"Database not initialized\");\n        }\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction([storeName], \"readonly\");\n            const store = transaction.objectStore(storeName);\n            const request = store.get(key);\n            request.onsuccess = () => {\n                const result = request.result || null;\n                setData(result);\n                resolve(result);\n            };\n            request.onerror = () => {\n                const errorMsg = `Failed to get item: ${request.error?.message}`;\n                setError(errorMsg);\n                reject(new Error(errorMsg));\n            };\n        });\n    }, [db, storeName]);\n    const removeItem = useCallback(async (key) => {\n        if (!db) {\n            throw new Error(\"Database not initialized\");\n        }\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction([storeName], \"readwrite\");\n            const store = transaction.objectStore(storeName);\n            const request = store.delete(key);\n            request.onsuccess = () => {\n                setData(null);\n                resolve();\n            };\n            request.onerror = () => {\n                const errorMsg = `Failed to remove item: ${request.error?.message}`;\n                setError(errorMsg);\n                reject(new Error(errorMsg));\n            };\n        });\n    }, [db, storeName]);\n    const clear = useCallback(async () => {\n        if (!db) {\n            throw new Error(\"Database not initialized\");\n        }\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction([storeName], \"readwrite\");\n            const store = transaction.objectStore(storeName);\n            const request = store.clear();\n            request.onsuccess = () => {\n                setData(null);\n                resolve();\n            };\n            request.onerror = () => {\n                const errorMsg = `Failed to clear store: ${request.error?.message}`;\n                setError(errorMsg);\n                reject(new Error(errorMsg));\n            };\n        });\n    }, [db, storeName]);\n    const getAllKeys = useCallback(async () => {\n        if (!db) {\n            throw new Error(\"Database not initialized\");\n        }\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction([storeName], \"readonly\");\n            const store = transaction.objectStore(storeName);\n            const request = store.getAllKeys();\n            request.onsuccess = () => {\n                resolve(request.result);\n            };\n            request.onerror = () => {\n                const errorMsg = `Failed to get keys: ${request.error?.message}`;\n                setError(errorMsg);\n                reject(new Error(errorMsg));\n            };\n        });\n    }, [db, storeName]);\n    return {\n        data,\n        error,\n        loading,\n        setItem,\n        getItem,\n        removeItem,\n        clear,\n        getAllKeys,\n    };\n}"
  }
}