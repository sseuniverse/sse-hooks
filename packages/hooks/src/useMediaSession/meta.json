{
  "$schema": "https://raw.githubusercontent.com/sseuniverse/sse-hooks/refs/heads/main/schema/meta.json",
  "name": "use-media-session",
  "type": "registry:hook",
  "title": "useMediaSession",
  "description": "Represents an image associated with the media (e.g., album art).",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [],
  "file": {
    "content": "export interface MediaImage {\r\n  \r\n  src: string;\r\n  \r\n  sizes?: string;\r\n  \r\n  type?: string;\r\n}\r\n\r\n\r\nexport interface MediaMetadataInit {\r\n  \r\n  title?: string;\r\n  \r\n  artist?: string;\r\n  \r\n  album?: string;\r\n  \r\n  artwork?: MediaImage[];\r\n}\r\n\r\n\r\nexport type MediaSessionAction =\r\n  | \"play\"\r\n  | \"pause\"\r\n  | \"stop\"\r\n  | \"seekbackward\"\r\n  | \"seekforward\"\r\n  | \"seekto\"\r\n  | \"skipad\"\r\n  | \"previoustrack\"\r\n  | \"nexttrack\";\r\n\r\n\r\nexport type MediaSessionPlaybackState = \"none\" | \"paused\" | \"playing\";\r\n\r\n\r\nexport type MediaSessionActionHandler = (details?: any) => void;\r\n\r\n\r\nexport interface UseMediaSessionOptions {\r\n  \r\n  metadata?: MediaMetadataInit;\r\n  \r\n  playbackState?: MediaSessionPlaybackState;\r\n  \r\n  actionHandlers?: Partial<\r\n    Record<MediaSessionAction, MediaSessionActionHandler>\r\n  >;\r\n}\r\n\r\n\r\nexport interface UseMediaSessionReturn {\r\n  \r\n  isSupported: boolean;\r\n  \r\n  setMetadata: (metadata: MediaMetadataInit) => void;\r\n  \r\n  setPlaybackState: (state: MediaSessionPlaybackState) => void;\r\n  \r\n  setActionHandler: (\r\n    action: MediaSessionAction,\r\n    handler: MediaSessionActionHandler | null,\r\n  ) => void;\r\n  \r\n  clearActionHandlers: () => void;\r\n}\r\n\nimport { useEffect, useCallback, useRef } from \"react\";\r\n\n\r\nexport const useMediaSession = (\r\n  options?: UseMediaSessionOptions,\r\n): UseMediaSessionReturn => {\r\n  const actionHandlersRef = useRef<Set<MediaSessionAction>>(new Set());\r\n\r\n  const isSupported =\r\n    typeof navigator !== \"undefined\" && \"mediaSession\" in navigator;\r\n\r\n  const setMetadata = useCallback(\r\n    (metadata: MediaMetadataInit) => {\r\n      if (!isSupported) return;\r\n\r\n      try {\r\n        navigator.mediaSession.metadata = new MediaMetadata(metadata);\r\n      } catch (error) {\r\n        console.warn(\"Failed to set media metadata:\", error);\r\n      }\r\n    },\r\n    [isSupported],\r\n  );\r\n\r\n  const setPlaybackState = useCallback(\r\n    (state: MediaSessionPlaybackState) => {\r\n      if (!isSupported) return;\r\n\r\n      try {\r\n        navigator.mediaSession.playbackState = state;\r\n      } catch (error) {\r\n        console.warn(\"Failed to set playback state:\", error);\r\n      }\r\n    },\r\n    [isSupported],\r\n  );\r\n\r\n  const setActionHandler = useCallback(\r\n    (action: MediaSessionAction, handler: MediaSessionActionHandler | null) => {\r\n      if (!isSupported) return;\r\n\r\n      try {\r\n        navigator.mediaSession.setActionHandler(action, handler);\r\n        if (handler) {\r\n          actionHandlersRef.current.add(action);\r\n        } else {\r\n          actionHandlersRef.current.delete(action);\r\n        }\r\n      } catch (error) {\r\n        console.warn(`Failed to set action handler for ${action}:`, error);\r\n      }\r\n    },\r\n    [isSupported],\r\n  );\r\n\r\n  const clearActionHandlers = useCallback(() => {\r\n    if (!isSupported) return;\r\n\r\n    actionHandlersRef.current.forEach((action) => {\r\n      try {\r\n        navigator.mediaSession.setActionHandler(action, null);\r\n      } catch (error) {\r\n        console.warn(`Failed to clear action handler for ${action}:`, error);\r\n      }\r\n    });\r\n    actionHandlersRef.current.clear();\r\n  }, [isSupported]);\r\n\r\n  \r\n  useEffect(() => {\r\n    if (options?.metadata) {\r\n      setMetadata(options.metadata);\r\n    }\r\n  }, [setMetadata, options?.metadata]);\r\n\r\n  \r\n  useEffect(() => {\r\n    if (options?.playbackState) {\r\n      setPlaybackState(options.playbackState);\r\n    }\r\n  }, [setPlaybackState, options?.playbackState]);\r\n\r\n  \r\n  useEffect(() => {\r\n    if (options?.actionHandlers) {\r\n      Object.entries(options.actionHandlers).forEach(([action, handler]) => {\r\n        if (handler) {\r\n          setActionHandler(action as MediaSessionAction, handler);\r\n        }\r\n      });\r\n    }\r\n\r\n    \r\n    return () => {\r\n      clearActionHandlers();\r\n    };\r\n  }, [setActionHandler, clearActionHandlers, options?.actionHandlers]);\r\n\r\n  return {\r\n    isSupported,\r\n    setMetadata,\r\n    setPlaybackState,\r\n    setActionHandler,\r\n    clearActionHandlers,\r\n  };\r\n};",
    "js": "import { useEffect, useCallback, useRef } from \"react\";\nexport const useMediaSession = (options) => {\n    const actionHandlersRef = useRef(new Set());\n    const isSupported = typeof navigator !== \"undefined\" && \"mediaSession\" in navigator;\n    const setMetadata = useCallback((metadata) => {\n        if (!isSupported)\n            return;\n        try {\n            navigator.mediaSession.metadata = new MediaMetadata(metadata);\n        }\n        catch (error) {\n            console.warn(\"Failed to set media metadata:\", error);\n        }\n    }, [isSupported]);\n    const setPlaybackState = useCallback((state) => {\n        if (!isSupported)\n            return;\n        try {\n            navigator.mediaSession.playbackState = state;\n        }\n        catch (error) {\n            console.warn(\"Failed to set playback state:\", error);\n        }\n    }, [isSupported]);\n    const setActionHandler = useCallback((action, handler) => {\n        if (!isSupported)\n            return;\n        try {\n            navigator.mediaSession.setActionHandler(action, handler);\n            if (handler) {\n                actionHandlersRef.current.add(action);\n            }\n            else {\n                actionHandlersRef.current.delete(action);\n            }\n        }\n        catch (error) {\n            console.warn(`Failed to set action handler for ${action}:`, error);\n        }\n    }, [isSupported]);\n    const clearActionHandlers = useCallback(() => {\n        if (!isSupported)\n            return;\n        actionHandlersRef.current.forEach((action) => {\n            try {\n                navigator.mediaSession.setActionHandler(action, null);\n            }\n            catch (error) {\n                console.warn(`Failed to clear action handler for ${action}:`, error);\n            }\n        });\n        actionHandlersRef.current.clear();\n    }, [isSupported]);\n    useEffect(() => {\n        if (options?.metadata) {\n            setMetadata(options.metadata);\n        }\n    }, [setMetadata, options?.metadata]);\n    useEffect(() => {\n        if (options?.playbackState) {\n            setPlaybackState(options.playbackState);\n        }\n    }, [setPlaybackState, options?.playbackState]);\n    useEffect(() => {\n        if (options?.actionHandlers) {\n            Object.entries(options.actionHandlers).forEach(([action, handler]) => {\n                if (handler) {\n                    setActionHandler(action, handler);\n                }\n            });\n        }\n        return () => {\n            clearActionHandlers();\n        };\n    }, [setActionHandler, clearActionHandlers, options?.actionHandlers]);\n    return {\n        isSupported,\n        setMetadata,\n        setPlaybackState,\n        setActionHandler,\n        clearActionHandlers,\n    };\n};"
  }
}