{
  "$schema": "https://raw.githubusercontent.com/sseuniverse/sse-hooks/refs/heads/main/schema/meta.json",
  "name": "use-media-session",
  "type": "registry:hook",
  "title": "useMediaSession",
  "description": "Represents an image associated with the media (e.g., album art).",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [],
  "file": {
    "content": "export interface MediaImage {\n  src: string;\n\n  sizes?: string;\n\n  type?: string;\n}\n\nexport interface MediaMetadataInit {\n  title?: string;\n\n  artist?: string;\n\n  album?: string;\n\n  artwork?: MediaImage[];\n}\n\nexport type MediaSessionAction =\n  | \"play\"\n  | \"pause\"\n  | \"stop\"\n  | \"seekbackward\"\n  | \"seekforward\"\n  | \"seekto\"\n  | \"skipad\"\n  | \"previoustrack\"\n  | \"nexttrack\";\n\nexport type MediaSessionPlaybackState = \"none\" | \"paused\" | \"playing\";\n\nexport type MediaSessionActionHandler = (details?: any) => void;\n\nexport interface UseMediaSessionOptions {\n  metadata?: MediaMetadataInit;\n\n  playbackState?: MediaSessionPlaybackState;\n\n  actionHandlers?: Partial<\n    Record<MediaSessionAction, MediaSessionActionHandler>\n  >;\n}\n\nexport interface UseMediaSessionReturn {\n  isSupported: boolean;\n\n  setMetadata: (metadata: MediaMetadataInit) => void;\n\n  setPlaybackState: (state: MediaSessionPlaybackState) => void;\n\n  setActionHandler: (\n    action: MediaSessionAction,\n    handler: MediaSessionActionHandler | null,\n  ) => void;\n\n  clearActionHandlers: () => void;\n}\n\nimport { useEffect, useCallback, useRef } from \"react\";\n\nexport const useMediaSession = (\n  options?: UseMediaSessionOptions,\n): UseMediaSessionReturn => {\n  const actionHandlersRef = useRef<Set<MediaSessionAction>>(new Set());\n\n  const isSupported =\n    typeof navigator !== \"undefined\" && \"mediaSession\" in navigator;\n\n  const setMetadata = useCallback(\n    (metadata: MediaMetadataInit) => {\n      if (!isSupported) return;\n\n      try {\n        navigator.mediaSession.metadata = new MediaMetadata(metadata);\n      } catch (error) {\n        console.warn(\"Failed to set media metadata:\", error);\n      }\n    },\n    [isSupported],\n  );\n\n  const setPlaybackState = useCallback(\n    (state: MediaSessionPlaybackState) => {\n      if (!isSupported) return;\n\n      try {\n        navigator.mediaSession.playbackState = state;\n      } catch (error) {\n        console.warn(\"Failed to set playback state:\", error);\n      }\n    },\n    [isSupported],\n  );\n\n  const setActionHandler = useCallback(\n    (action: MediaSessionAction, handler: MediaSessionActionHandler | null) => {\n      if (!isSupported) return;\n\n      try {\n        navigator.mediaSession.setActionHandler(action, handler);\n        if (handler) {\n          actionHandlersRef.current.add(action);\n        } else {\n          actionHandlersRef.current.delete(action);\n        }\n      } catch (error) {\n        console.warn(`Failed to set action handler for ${action}:`, error);\n      }\n    },\n    [isSupported],\n  );\n\n  const clearActionHandlers = useCallback(() => {\n    if (!isSupported) return;\n\n    actionHandlersRef.current.forEach((action) => {\n      try {\n        navigator.mediaSession.setActionHandler(action, null);\n      } catch (error) {\n        console.warn(`Failed to clear action handler for ${action}:`, error);\n      }\n    });\n    actionHandlersRef.current.clear();\n  }, [isSupported]);\n\n  useEffect(() => {\n    if (options?.metadata) {\n      setMetadata(options.metadata);\n    }\n  }, [setMetadata, options?.metadata]);\n\n  useEffect(() => {\n    if (options?.playbackState) {\n      setPlaybackState(options.playbackState);\n    }\n  }, [setPlaybackState, options?.playbackState]);\n\n  useEffect(() => {\n    if (options?.actionHandlers) {\n      Object.entries(options.actionHandlers).forEach(([action, handler]) => {\n        if (handler) {\n          setActionHandler(action as MediaSessionAction, handler);\n        }\n      });\n    }\n\n    return () => {\n      clearActionHandlers();\n    };\n  }, [setActionHandler, clearActionHandlers, options?.actionHandlers]);\n\n  return {\n    isSupported,\n    setMetadata,\n    setPlaybackState,\n    setActionHandler,\n    clearActionHandlers,\n  };\n};\n",
    "js": "import { useEffect, useCallback, useRef } from \"react\";\nexport const useMediaSession = (options) => {\n    const actionHandlersRef = useRef(new Set());\n    const isSupported = typeof navigator !== \"undefined\" && \"mediaSession\" in navigator;\n    const setMetadata = useCallback((metadata) => {\n        if (!isSupported)\n            return;\n        try {\n            navigator.mediaSession.metadata = new MediaMetadata(metadata);\n        }\n        catch (error) {\n            console.warn(\"Failed to set media metadata:\", error);\n        }\n    }, [isSupported]);\n    const setPlaybackState = useCallback((state) => {\n        if (!isSupported)\n            return;\n        try {\n            navigator.mediaSession.playbackState = state;\n        }\n        catch (error) {\n            console.warn(\"Failed to set playback state:\", error);\n        }\n    }, [isSupported]);\n    const setActionHandler = useCallback((action, handler) => {\n        if (!isSupported)\n            return;\n        try {\n            navigator.mediaSession.setActionHandler(action, handler);\n            if (handler) {\n                actionHandlersRef.current.add(action);\n            }\n            else {\n                actionHandlersRef.current.delete(action);\n            }\n        }\n        catch (error) {\n            console.warn(`Failed to set action handler for ${action}:`, error);\n        }\n    }, [isSupported]);\n    const clearActionHandlers = useCallback(() => {\n        if (!isSupported)\n            return;\n        actionHandlersRef.current.forEach((action) => {\n            try {\n                navigator.mediaSession.setActionHandler(action, null);\n            }\n            catch (error) {\n                console.warn(`Failed to clear action handler for ${action}:`, error);\n            }\n        });\n        actionHandlersRef.current.clear();\n    }, [isSupported]);\n    useEffect(() => {\n        if (options?.metadata) {\n            setMetadata(options.metadata);\n        }\n    }, [setMetadata, options?.metadata]);\n    useEffect(() => {\n        if (options?.playbackState) {\n            setPlaybackState(options.playbackState);\n        }\n    }, [setPlaybackState, options?.playbackState]);\n    useEffect(() => {\n        if (options?.actionHandlers) {\n            Object.entries(options.actionHandlers).forEach(([action, handler]) => {\n                if (handler) {\n                    setActionHandler(action, handler);\n                }\n            });\n        }\n        return () => {\n            clearActionHandlers();\n        };\n    }, [setActionHandler, clearActionHandlers, options?.actionHandlers]);\n    return {\n        isSupported,\n        setMetadata,\n        setPlaybackState,\n        setActionHandler,\n        clearActionHandlers,\n    };\n};"
  }
}